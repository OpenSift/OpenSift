from __future__ import annotations

import argparse
import getpass
import json
import os
import signal
import shutil
import subprocess
import sys
import time
import urllib.error
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional

from app.logging_utils import configure_logging
from app.security_audit import format_audit_report, run_security_audit

logger = configure_logging("opensift.launcher")
OPENSIFT_VERSION = "1.3.1-alpha"


def run_ui(host: str, port: int, reload: bool) -> None:
    import uvicorn  # type: ignore

    uvicorn.run(
        "ui_app:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info",
    )


def run_terminal(argv: list[str]) -> None:
    from cli_chat import main as cli_main  # type: ignore

    old_argv = sys.argv[:]
    try:
        sys.argv = ["cli_chat.py", *argv]
        cli_main()
    finally:
        sys.argv = old_argv


@dataclass
class ManagedProc:
    name: str
    proc: subprocess.Popen


def _parse_env_file(path: str) -> Dict[str, str]:
    data: Dict[str, str] = {}
    if not os.path.exists(path):
        return data

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            data[key.strip()] = value.strip()
    return data


def _write_env_file(path: str, values: Dict[str, str]) -> None:
    lines = [
        "# OpenSift local environment",
        "# Generated by: python opensift.py setup",
        "",
    ]
    for key in sorted(values.keys()):
        val = values[key].replace("\n", "\\n")
        lines.append(f"{key}={val}")
    lines.append("")

    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    try:
        os.chmod(path, 0o600)
    except Exception:
        pass


def _mask(value: str) -> str:
    if not value:
        return "(not set)"
    if len(value) <= 8:
        return "*" * len(value)
    return f"{value[:4]}...{value[-4:]}"


def _prompt_value(label: str, current: str, secret: bool = True) -> Optional[str]:
    shown = _mask(current)
    print(f"\n{label}")
    print(f"Current: {shown}")
    print("Leave blank to keep current value. Type 'none' to clear.")
    prompt = "New value: "
    raw = getpass.getpass(prompt) if secret else input(prompt)
    value = raw.strip()

    if value == "":
        return None
    if value.lower() == "none":
        return ""
    return value


def _prompt_choice(label: str, choices: list[str], default: str) -> str:
    joined = "/".join(choices)
    while True:
        raw = input(f"{label} [{joined}] (default: {default}): ").strip().lower()
        if not raw:
            return default
        if raw in choices:
            return raw
        print(f"Please choose one of: {joined}")


def _apply_env(values: Dict[str, str]) -> None:
    for key, val in values.items():
        if val:
            os.environ[key] = val
        else:
            os.environ.pop(key, None)


def _terminal_args_for_provider(provider: str) -> list[str]:
    return ["--provider", provider]


def _env_or_file(env_data: Dict[str, str], key: str) -> str:
    return os.environ.get(key, "").strip() or env_data.get(key, "").strip()


def _claude_code_cli_available(env_data: Dict[str, str]) -> bool:
    cmd = (_env_or_file(env_data, "OPENSIFT_CLAUDE_CODE_CMD") or "claude").strip() or "claude"
    return bool(shutil.which(cmd))


def _maybe_prompt_cli_install(
    env_data: Dict[str, str],
    label: str,
    env_key: str,
    default_cmd: str,
    suggested_install: str,
    skip_prompts: bool = False,
) -> None:
    cmd = (_env_or_file(env_data, env_key) or default_cmd).strip() or default_cmd
    if shutil.which(cmd):
        print(f"{label} CLI detected: {cmd}")
        return

    print(f"\n⚠️ {label} CLI not found on PATH (command: {cmd})")
    if skip_prompts:
        print(f"Skipping {label} install prompt.")
        return

    if _prompt_choice(f"Install {label} CLI now", ["y", "n"], default="n") != "y":
        print(f"Skipping {label} install.")
        return

    install_cmd = input(
        f"Install command (default: {suggested_install}; blank to skip): "
    ).strip()
    if not install_cmd:
        install_cmd = suggested_install.strip()
    if not install_cmd:
        print("No install command provided. Skipping.")
        return

    try:
        rc = subprocess.run(install_cmd, shell=True, check=False).returncode
    except Exception as e:
        print(f"Install command failed to start: {e}")
        return

    if rc != 0:
        print(f"Install command exited with code {rc}. Continue setup and configure {env_key} manually if needed.")
        return

    if shutil.which(cmd):
        print(f"{label} CLI installation complete: {cmd}")
    else:
        print(f"Install command completed, but '{cmd}' is still not detected. You may need to set {env_key}.")


def _choose_default_provider(env_data: Dict[str, str]) -> str:
    if _claude_code_cli_available(env_data):
        return "claude_code"
    if (env_data.get("ANTHROPIC_API_KEY") or "").strip():
        return "claude"
    if (env_data.get("CHATGPT_CODEX_OAUTH_TOKEN") or "").strip() or _codex_auth_file_token():
        return "codex"
    if (env_data.get("OPENAI_API_KEY") or "").strip():
        return "openai"
    if (env_data.get("CLAUDE_CODE_OAUTH_TOKEN") or "").strip():
        return "claude_code"
    return "claude_code"


def _codex_auth_file_token() -> str:
    override = os.environ.get("OPENSIFT_CODEX_AUTH_PATH", "").strip()
    paths = []
    if override:
        paths.append(os.path.expanduser(override))
    paths.extend(
        [
            "/app/.codex/auth.json",
            os.path.join(os.path.expanduser("~"), ".codex", "auth.json"),
        ]
    )

    preferred_keys = (
        "chatgpt_codex_oauth_token",
        "codex_oauth_token",
        "oauth_token",
        "access_token",
        "id_token",
        "token",
    )

    def find(obj) -> str:
        if isinstance(obj, dict):
            lower = {str(k).lower(): v for k, v in obj.items()}
            for k in preferred_keys:
                v = lower.get(k)
                if isinstance(v, str) and v.strip():
                    return v.strip()
            for v in obj.values():
                s = find(v)
                if s:
                    return s
            return ""
        if isinstance(obj, list):
            for v in obj:
                s = find(v)
                if s:
                    return s
            return ""
        return ""

    seen = set()
    for path in paths:
        p = os.path.abspath(path)
        if p in seen:
            continue
        seen.add(p)
        if not os.path.exists(p):
            continue
        try:
            with open(p, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            continue
        token = find(data)
        if token:
            return token
    return ""


def _gateway_provider_summary(env_data: Dict[str, str]) -> List[str]:
    out: List[str] = []
    openai_key = _env_or_file(env_data, "OPENAI_API_KEY")
    anthropic_key = _env_or_file(env_data, "ANTHROPIC_API_KEY")
    claude_token = _env_or_file(env_data, "CLAUDE_CODE_OAUTH_TOKEN")
    codex_token = _env_or_file(env_data, "CHATGPT_CODEX_OAUTH_TOKEN") or _codex_auth_file_token()
    claude_cmd = _env_or_file(env_data, "OPENSIFT_CLAUDE_CODE_CMD") or "claude"
    codex_cmd = _env_or_file(env_data, "OPENSIFT_CODEX_CMD") or "codex"

    out.append(f"OpenAI API key: {'configured' if openai_key else 'not set'}")
    out.append(f"Anthropic API key: {'configured' if anthropic_key else 'not set'}")
    out.append(f"Claude Code token: {'configured' if claude_token else 'not set'}")
    out.append(f"ChatGPT Codex OAuth token: {'configured' if codex_token else 'not set'}")
    out.append(f"Claude Code command: {claude_cmd}")
    out.append(f"Codex command: {codex_cmd}")
    return out


def _cmd_looks_like_wrong_codex(cmd: str) -> bool:
    try:
        proc = subprocess.run(
            [cmd, "--help"],
            text=True,
            capture_output=True,
            timeout=4,
            env=os.environ.copy(),
        )
        out = ((proc.stdout or "") + "\n" + (proc.stderr or "")).lower()
        return ("render your codex" in out) or ("codex build" in out and "template" in out)
    except Exception:
        return False


def _wait_for_http_health(url: str, timeout_s: float) -> bool:
    start = time.time()
    while (time.time() - start) < timeout_s:
        try:
            with urllib.request.urlopen(url, timeout=2.0) as resp:
                if 200 <= getattr(resp, "status", 0) < 300:
                    return True
        except (urllib.error.URLError, urllib.error.HTTPError, TimeoutError):
            time.sleep(0.35)
            continue
    return False


def _health_probe_host(bind_host: str) -> str:
    h = (bind_host or "").strip().lower()
    # 0.0.0.0 / :: are bind-all addresses, not valid probe hosts for guarded localhost checks.
    if h in ("0.0.0.0", "::", "[::]"):
        return "127.0.0.1"
    return bind_host


def _terminate_managed(procs: List[ManagedProc]) -> None:
    for mp in procs:
        if mp.proc.poll() is None:
            mp.proc.terminate()

    deadline = time.time() + 6
    for mp in procs:
        if mp.proc.poll() is None:
            left = max(0.1, deadline - time.time())
            try:
                mp.proc.wait(timeout=left)
            except Exception:
                pass

    for mp in procs:
        if mp.proc.poll() is None:
            mp.proc.kill()


def _is_non_fatal_service_exit(name: str, rc: int) -> bool:
    # MCP can validly exit in non-interactive environments (e.g., Docker detached mode).
    return name == "mcp" and rc == 0


def run_gateway(host: str, port: int, reload: bool, with_mcp: bool, health_timeout: float) -> int:
    env_path = os.path.join(os.getcwd(), ".env")
    env_data = _parse_env_file(env_path)
    _apply_env(env_data)

    print("\nOpenSift Gateway")
    print("=" * 72)
    for line in _gateway_provider_summary(env_data):
        print(f"- {line}")
    print("=" * 72)

    managed: List[ManagedProc] = []

    ui_cmd = [sys.executable, "opensift.py", "ui", "--host", host, "--port", str(port)]
    if reload:
        ui_cmd.append("--reload")
    ui_proc = subprocess.Popen(ui_cmd)
    managed.append(ManagedProc(name="ui", proc=ui_proc))
    print(f"[gateway] starting ui (pid={ui_proc.pid}) -> http://{host}:{port}")
    logger.info("gateway_start_ui pid=%d host=%s port=%d reload=%s", ui_proc.pid, host, port, reload)

    if with_mcp:
        mcp_cmd = [sys.executable, "mcp_server.py"]
        mcp_proc = subprocess.Popen(mcp_cmd)
        managed.append(ManagedProc(name="mcp", proc=mcp_proc))
        print(f"[gateway] starting mcp (pid={mcp_proc.pid}) -> stdio")
        logger.info("gateway_start_mcp pid=%d", mcp_proc.pid)

    stop_flag = {"stop": False}

    def _handle_stop(signum, _frame):
        _ = signum
        stop_flag["stop"] = True

    signal.signal(signal.SIGINT, _handle_stop)
    signal.signal(signal.SIGTERM, _handle_stop)

    probe_host = _health_probe_host(host)
    health_url = f"http://{probe_host}:{port}/health"
    ok = _wait_for_http_health(health_url, timeout_s=health_timeout)
    if not ok:
        print(f"[gateway] ui health check failed after {health_timeout:.1f}s: {health_url} (bind={host})")
        logger.error("gateway_health_failed url=%s bind_host=%s timeout_s=%.1f", health_url, host, health_timeout)
        _terminate_managed(managed)
        return 1

    print(f"[gateway] ui is healthy: {health_url} (bind={host})")
    print("[gateway] running. Press Ctrl+C to stop all services.")
    logger.info("gateway_running health_url=%s bind_host=%s", health_url, host)

    try:
        while not stop_flag["stop"]:
            for mp in list(managed):
                rc = mp.proc.poll()
                if rc is not None:
                    if _is_non_fatal_service_exit(mp.name, rc):
                        print(f"[gateway] service '{mp.name}' exited cleanly (code {rc}); continuing without it.")
                        logger.warning("gateway_service_exited_non_fatal name=%s rc=%d", mp.name, rc)
                        managed.remove(mp)
                        continue
                    print(f"[gateway] service '{mp.name}' exited with code {rc}")
                    logger.error("gateway_service_exited name=%s rc=%d", mp.name, rc)
                    _terminate_managed(managed)
                    return rc if rc != 0 else 1
            time.sleep(0.4)
    finally:
        _terminate_managed(managed)

    return 0


def _run_both(host: str, port: int, reload: bool, term_args: list[str]) -> None:
    cmd = [sys.executable, "opensift.py", "ui", "--host", host, "--port", str(port)]
    if reload:
        cmd.append("--reload")

    ui_proc = subprocess.Popen(cmd)
    print(f"\nStarted UI at http://{host}:{port} (pid={ui_proc.pid})")
    print("Starting terminal chat. When terminal exits, UI process will stop.\n")

    try:
        run_terminal(term_args)
    finally:
        ui_proc.terminate()
        try:
            ui_proc.wait(timeout=5)
        except Exception:
            ui_proc.kill()


def run_security_audit_cmd(fix_perms: bool = False, fail_on_warn: bool = False) -> int:
    findings, rc = run_security_audit(Path(os.getcwd()), fix_perms=fix_perms)
    print("\n" + format_audit_report(findings) + "\n")
    if rc == 2 and not fail_on_warn:
        return 0
    return 1 if rc != 0 else 0


def run_setup(
    skip_key_prompts: bool = False,
    no_launch: bool = False,
    skip_cli_install_prompts: bool = False,
) -> None:
    env_path = os.path.join(os.getcwd(), ".env")
    env_data = _parse_env_file(env_path)

    print("\nOpenSift Setup Wizard")
    print("=" * 72)
    print("This will configure API/token keys and optionally launch OpenSift.\n")

    updated = dict(env_data)
    if not skip_key_prompts:
        key_specs = [
            ("OPENAI_API_KEY", "OpenAI API key (optional)"),
            ("ANTHROPIC_API_KEY", "Anthropic API key (optional)"),
            ("CLAUDE_CODE_OAUTH_TOKEN", "Claude Code OAuth token (optional)"),
            ("CHATGPT_CODEX_OAUTH_TOKEN", "ChatGPT Codex OAuth token (optional)"),
            ("OPENSIFT_CLAUDE_CODE_CMD", "Claude Code command (default: claude)"),
            ("OPENSIFT_CLAUDE_CODE_ARGS", "Claude Code extra args (optional)"),
            ("OPENSIFT_CODEX_CMD", "Codex command (default: codex)"),
            ("OPENSIFT_CODEX_ARGS", "Codex extra args (optional)"),
        ]

        for key, label in key_specs:
            secret = key not in (
                "OPENSIFT_CLAUDE_CODE_CMD",
                "OPENSIFT_CLAUDE_CODE_ARGS",
                "OPENSIFT_CODEX_CMD",
                "OPENSIFT_CODEX_ARGS",
            )
            current = updated.get(key, "")
            value = _prompt_value(label, current=current, secret=secret)
            if value is None:
                continue
            if value == "":
                updated.pop(key, None)
            else:
                updated[key] = value

        _write_env_file(env_path, updated)
        print(f"\nSaved environment config: {env_path}")
    else:
        print("\nSkipping key prompts (using existing .env values).")

    _apply_env(updated)
    _maybe_prompt_cli_install(
        updated,
        label="Claude Code",
        env_key="OPENSIFT_CLAUDE_CODE_CMD",
        default_cmd="claude",
        suggested_install="npm install -g @anthropic-ai/claude-code",
        skip_prompts=skip_cli_install_prompts,
    )
    _maybe_prompt_cli_install(
        updated,
        label="ChatGPT Codex",
        env_key="OPENSIFT_CODEX_CMD",
        default_cmd="codex",
        suggested_install="npm install -g @openai/codex",
        skip_prompts=skip_cli_install_prompts,
    )
    codex_cmd = (updated.get("OPENSIFT_CODEX_CMD") or "codex").strip()
    if updated.get("CHATGPT_CODEX_OAUTH_TOKEN") and _cmd_looks_like_wrong_codex(codex_cmd):
        print("\n⚠️ Codex command validation warning:")
        print(f"   '{codex_cmd}' appears to be the unrelated npm 'codex' package (site generator).")
        print("   Install the ChatGPT Codex CLI and set OPENSIFT_CODEX_CMD to the correct executable.")

    print("\nRunning security audit before launch...")
    audit_rc = run_security_audit_cmd(fix_perms=True, fail_on_warn=False)
    if audit_rc != 0:
        print("⚠️ Security audit reported remaining high-severity findings. Please resolve before launch.")
        if _prompt_choice("Continue anyway", ["y", "n"], default="n") != "y":
            raise SystemExit(1)

    if no_launch:
        print("Setup complete (launch skipped).")
        return

    print("\nLaunch mode options:")
    print("  - ui       : Web chatbot (FastAPI UI)")
    print("  - terminal : Terminal chatbot")
    print("  - gateway  : Supervised gateway (UI + optional MCP)")
    print("  - both     : Start UI + terminal together")
    print("  - none     : Exit setup without launching")
    print("\nNote: ChatGPT Codex OAuth is captured for local Codex CLI integrations.")

    mode = _prompt_choice("Choose launch mode", ["ui", "terminal", "gateway", "both", "none"], default="gateway")
    if mode == "none":
        print("Setup complete.")
        return

    host = input("UI host (default: 127.0.0.1): ").strip() or "127.0.0.1"
    port_raw = input("UI port (default: 8001): ").strip() or "8001"
    try:
        port = int(port_raw)
    except ValueError:
        port = 8001
    reload = _prompt_choice("Enable auto-reload", ["y", "n"], default="y") == "y"

    provider_default = _choose_default_provider(updated)

    provider = _prompt_choice(
        "Terminal provider",
        ["openai", "claude", "claude_code", "codex"],
        default=provider_default,
    )
    term_args = _terminal_args_for_provider(provider)

    if mode == "ui":
        run_ui(host, port, reload)
        return
    if mode == "terminal":
        run_terminal(term_args)
        return
    if mode == "gateway":
        with_mcp = _prompt_choice("Launch MCP server too", ["y", "n"], default="y") == "y"
        rc = run_gateway(host=host, port=port, reload=reload, with_mcp=with_mcp, health_timeout=20.0)
        raise SystemExit(rc)
    _run_both(host, port, reload, term_args)


def main() -> None:
    parser = argparse.ArgumentParser(description="OpenSift Launcher (UI, Terminal, Gateway)")
    parser.add_argument("--version", action="version", version=f"OpenSift {OPENSIFT_VERSION}")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_setup = sub.add_parser("setup", help="Interactive setup wizard for keys + launch mode")
    p_setup.add_argument(
        "--skip-key-prompts",
        action="store_true",
        help="Skip key/token prompts and use existing values from .env",
    )
    p_setup.add_argument(
        "--no-launch",
        action="store_true",
        help="Run setup and security audit, then exit without launching services",
    )
    p_setup.add_argument(
        "--skip-cli-install-prompts",
        action="store_true",
        help="Skip prompts to install missing Claude/Codex CLIs",
    )

    p_audit = sub.add_parser("security-audit", help="Run local security audit checks for OpenSift setup")
    p_audit.add_argument("--fix-perms", action="store_true", help="Auto-fix restrictive file/dir permissions when possible")
    p_audit.add_argument("--fail-on-warn", action="store_true", help="Return non-zero when warnings are found")

    p_ui = sub.add_parser("ui", help="Run localhost web UI")
    p_ui.add_argument("--host", default="127.0.0.1", help="Bind host (default: 127.0.0.1)")
    p_ui.add_argument("--port", type=int, default=8001, help="Port (default: 8001)")
    p_ui.add_argument("--reload", action="store_true", help="Enable auto-reload")

    p_term = sub.add_parser("terminal", help="Run terminal chatbot")
    p_term.add_argument("--owner", default="default", help="Owner/namespace")
    p_term.add_argument("--mode", default="study_guide", help="Mode")
    p_term.add_argument("--provider", default="claude_code", choices=["openai", "claude", "claude_code", "codex"])
    p_term.add_argument("--model", default="", help="Model override (optional)")
    p_term.add_argument("--k", type=int, default=8, help="Top-k retrieval")
    p_term.add_argument("--wrap", type=int, default=100, help="Wrap width")
    p_term.add_argument("--history-turns", type=int, default=10, help="How many messages to include as history")
    p_term.add_argument("--no-stream", action="store_true", help="Disable streaming output")
    p_term.add_argument("--no-true-stream", action="store_true", help="Disable provider-native true streaming")
    p_term.add_argument("--no-show-thinking", action="store_true", help="Hide retrieval/thinking status lines")
    p_term.add_argument("--thinking", action="store_true", help="Enable Claude extended thinking where supported")
    p_term.add_argument(
        "--thinking-level",
        default="medium",
        choices=["low", "medium", "high", "extra_high"],
        help="Claude thinking level",
    )
    p_term.add_argument("--no-sources", action="store_true", help="Disable sources printing")

    p_gateway = sub.add_parser("gateway", help="Run supervised OpenSift gateway (UI + optional MCP)")
    p_gateway.add_argument("--host", default="127.0.0.1", help="UI bind host (default: 127.0.0.1)")
    p_gateway.add_argument("--port", type=int, default=8001, help="UI port (default: 8001)")
    p_gateway.add_argument("--reload", action="store_true", help="Enable UI auto-reload")
    p_gateway.add_argument("--with-mcp", action="store_true", help="Also launch MCP server")
    p_gateway.add_argument("--health-timeout", type=float, default=20.0, help="Seconds to wait for UI health")

    args, extras = parser.parse_known_args()

    this_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(this_dir)

    if args.cmd == "setup":
        logger.info(
            "launcher_cmd setup skip_key_prompts=%s no_launch=%s",
            bool(getattr(args, "skip_key_prompts", False)),
            bool(getattr(args, "no_launch", False)),
        )
        run_setup(
            skip_key_prompts=bool(getattr(args, "skip_key_prompts", False)),
            no_launch=bool(getattr(args, "no_launch", False)),
            skip_cli_install_prompts=bool(getattr(args, "skip_cli_install_prompts", False)),
        )
        return

    if args.cmd == "security-audit":
        logger.info(
            "launcher_cmd security_audit fix_perms=%s fail_on_warn=%s",
            bool(getattr(args, "fix_perms", False)),
            bool(getattr(args, "fail_on_warn", False)),
        )
        rc = run_security_audit_cmd(
            fix_perms=bool(getattr(args, "fix_perms", False)),
            fail_on_warn=bool(getattr(args, "fail_on_warn", False)),
        )
        raise SystemExit(rc)
        return

    if args.cmd == "ui":
        logger.info("launcher_cmd ui host=%s port=%d reload=%s", args.host, args.port, args.reload)
        run_ui(args.host, args.port, args.reload)
        return

    if args.cmd == "gateway":
        logger.info(
            "launcher_cmd gateway host=%s port=%d reload=%s with_mcp=%s health_timeout=%.1f",
            args.host,
            args.port,
            args.reload,
            args.with_mcp,
            args.health_timeout,
        )
        rc = run_gateway(
            host=args.host,
            port=args.port,
            reload=args.reload,
            with_mcp=args.with_mcp,
            health_timeout=args.health_timeout,
        )
        raise SystemExit(rc)

    if args.cmd == "terminal":
        logger.info("launcher_cmd terminal owner=%s mode=%s provider=%s", args.owner, args.mode, args.provider)
        forwarded = [
            "--owner",
            args.owner,
            "--mode",
            args.mode,
            "--provider",
            args.provider,
            "--model",
            args.model,
            "--k",
            str(args.k),
            "--wrap",
            str(args.wrap),
            "--history-turns",
            str(args.history_turns),
        ]
        if args.no_stream:
            forwarded.append("--no-stream")
        if args.no_true_stream:
            forwarded.append("--no-true-stream")
        if args.no_show_thinking:
            forwarded.append("--no-show-thinking")
        if args.thinking:
            forwarded.append("--thinking")
        if args.thinking_level:
            forwarded.extend(["--thinking-level", args.thinking_level])
        if args.no_sources:
            forwarded.append("--no-sources")

        run_terminal(forwarded + extras)
        return


if __name__ == "__main__":
    main()
