from __future__ import annotations

import argparse
import getpass
import json
import os
import signal
import subprocess
import sys
import time
import urllib.error
import urllib.request
from dataclasses import dataclass
from typing import Dict, List, Optional

from app.logging_utils import configure_logging

logger = configure_logging("opensift.launcher")
OPENSIFT_VERSION = "1.1.3-alpha"


def run_ui(host: str, port: int, reload: bool) -> None:
    import uvicorn  # type: ignore

    uvicorn.run(
        "ui_app:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info",
    )


def run_terminal(argv: list[str]) -> None:
    from cli_chat import main as cli_main  # type: ignore

    old_argv = sys.argv[:]
    try:
        sys.argv = ["cli_chat.py", *argv]
        cli_main()
    finally:
        sys.argv = old_argv


@dataclass
class ManagedProc:
    name: str
    proc: subprocess.Popen


def _parse_env_file(path: str) -> Dict[str, str]:
    data: Dict[str, str] = {}
    if not os.path.exists(path):
        return data

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            data[key.strip()] = value.strip()
    return data


def _write_env_file(path: str, values: Dict[str, str]) -> None:
    lines = [
        "# OpenSift local environment",
        "# Generated by: python opensift.py setup",
        "",
    ]
    for key in sorted(values.keys()):
        val = values[key].replace("\n", "\\n")
        lines.append(f"{key}={val}")
    lines.append("")

    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))


def _mask(value: str) -> str:
    if not value:
        return "(not set)"
    if len(value) <= 8:
        return "*" * len(value)
    return f"{value[:4]}...{value[-4:]}"


def _prompt_value(label: str, current: str, secret: bool = True) -> Optional[str]:
    shown = _mask(current)
    print(f"\n{label}")
    print(f"Current: {shown}")
    print("Leave blank to keep current value. Type 'none' to clear.")
    prompt = "New value: "
    raw = getpass.getpass(prompt) if secret else input(prompt)
    value = raw.strip()

    if value == "":
        return None
    if value.lower() == "none":
        return ""
    return value


def _prompt_choice(label: str, choices: list[str], default: str) -> str:
    joined = "/".join(choices)
    while True:
        raw = input(f"{label} [{joined}] (default: {default}): ").strip().lower()
        if not raw:
            return default
        if raw in choices:
            return raw
        print(f"Please choose one of: {joined}")


def _apply_env(values: Dict[str, str]) -> None:
    for key, val in values.items():
        if val:
            os.environ[key] = val
        else:
            os.environ.pop(key, None)


def _terminal_args_for_provider(provider: str) -> list[str]:
    return ["--provider", provider]


def _env_or_file(env_data: Dict[str, str], key: str) -> str:
    return os.environ.get(key, "").strip() or env_data.get(key, "").strip()


def _codex_auth_file_token() -> str:
    path = os.environ.get("OPENSIFT_CODEX_AUTH_PATH", "").strip() or os.path.join(
        os.path.expanduser("~"),
        ".codex",
        "auth.json",
    )
    if not os.path.exists(path):
        return ""
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception:
        return ""

    preferred_keys = (
        "chatgpt_codex_oauth_token",
        "codex_oauth_token",
        "oauth_token",
        "access_token",
        "id_token",
        "token",
    )

    def find(obj) -> str:
        if isinstance(obj, dict):
            lower = {str(k).lower(): v for k, v in obj.items()}
            for k in preferred_keys:
                v = lower.get(k)
                if isinstance(v, str) and v.strip():
                    return v.strip()
            for v in obj.values():
                s = find(v)
                if s:
                    return s
            return ""
        if isinstance(obj, list):
            for v in obj:
                s = find(v)
                if s:
                    return s
            return ""
        return ""

    return find(data)


def _gateway_provider_summary(env_data: Dict[str, str]) -> List[str]:
    out: List[str] = []
    openai_key = _env_or_file(env_data, "OPENAI_API_KEY")
    anthropic_key = _env_or_file(env_data, "ANTHROPIC_API_KEY")
    claude_token = _env_or_file(env_data, "CLAUDE_CODE_OAUTH_TOKEN")
    codex_token = _env_or_file(env_data, "CHATGPT_CODEX_OAUTH_TOKEN") or _codex_auth_file_token()
    claude_cmd = _env_or_file(env_data, "OPENSIFT_CLAUDE_CODE_CMD") or "claude"
    codex_cmd = _env_or_file(env_data, "OPENSIFT_CODEX_CMD") or "codex"

    out.append(f"OpenAI API key: {'configured' if openai_key else 'not set'}")
    out.append(f"Anthropic API key: {'configured' if anthropic_key else 'not set'}")
    out.append(f"Claude Code token: {'configured' if claude_token else 'not set'}")
    out.append(f"ChatGPT Codex OAuth token: {'configured' if codex_token else 'not set'}")
    out.append(f"Claude Code command: {claude_cmd}")
    out.append(f"Codex command: {codex_cmd}")
    return out


def _cmd_looks_like_wrong_codex(cmd: str) -> bool:
    try:
        proc = subprocess.run(
            [cmd, "--help"],
            text=True,
            capture_output=True,
            timeout=4,
            env=os.environ.copy(),
        )
        out = ((proc.stdout or "") + "\n" + (proc.stderr or "")).lower()
        return ("render your codex" in out) or ("codex build" in out and "template" in out)
    except Exception:
        return False


def _wait_for_http_health(url: str, timeout_s: float) -> bool:
    start = time.time()
    while (time.time() - start) < timeout_s:
        try:
            with urllib.request.urlopen(url, timeout=2.0) as resp:
                if 200 <= getattr(resp, "status", 0) < 300:
                    return True
        except (urllib.error.URLError, urllib.error.HTTPError, TimeoutError):
            time.sleep(0.35)
            continue
    return False


def _terminate_managed(procs: List[ManagedProc]) -> None:
    for mp in procs:
        if mp.proc.poll() is None:
            mp.proc.terminate()

    deadline = time.time() + 6
    for mp in procs:
        if mp.proc.poll() is None:
            left = max(0.1, deadline - time.time())
            try:
                mp.proc.wait(timeout=left)
            except Exception:
                pass

    for mp in procs:
        if mp.proc.poll() is None:
            mp.proc.kill()


def run_gateway(host: str, port: int, reload: bool, with_mcp: bool, health_timeout: float) -> int:
    env_path = os.path.join(os.getcwd(), ".env")
    env_data = _parse_env_file(env_path)

    print("\nOpenSift Gateway")
    print("=" * 72)
    for line in _gateway_provider_summary(env_data):
        print(f"- {line}")
    print("=" * 72)

    managed: List[ManagedProc] = []

    ui_cmd = [sys.executable, "opensift.py", "ui", "--host", host, "--port", str(port)]
    if reload:
        ui_cmd.append("--reload")
    ui_proc = subprocess.Popen(ui_cmd)
    managed.append(ManagedProc(name="ui", proc=ui_proc))
    print(f"[gateway] starting ui (pid={ui_proc.pid}) -> http://{host}:{port}")
    logger.info("gateway_start_ui pid=%d host=%s port=%d reload=%s", ui_proc.pid, host, port, reload)

    if with_mcp:
        mcp_cmd = [sys.executable, "mcp_server.py"]
        mcp_proc = subprocess.Popen(mcp_cmd)
        managed.append(ManagedProc(name="mcp", proc=mcp_proc))
        print(f"[gateway] starting mcp (pid={mcp_proc.pid}) -> stdio")
        logger.info("gateway_start_mcp pid=%d", mcp_proc.pid)

    stop_flag = {"stop": False}

    def _handle_stop(signum, _frame):
        _ = signum
        stop_flag["stop"] = True

    signal.signal(signal.SIGINT, _handle_stop)
    signal.signal(signal.SIGTERM, _handle_stop)

    health_url = f"http://{host}:{port}/health"
    ok = _wait_for_http_health(health_url, timeout_s=health_timeout)
    if not ok:
        print(f"[gateway] ui health check failed after {health_timeout:.1f}s: {health_url}")
        logger.error("gateway_health_failed url=%s timeout_s=%.1f", health_url, health_timeout)
        _terminate_managed(managed)
        return 1

    print(f"[gateway] ui is healthy: {health_url}")
    print("[gateway] running. Press Ctrl+C to stop all services.")
    logger.info("gateway_running health_url=%s", health_url)

    try:
        while not stop_flag["stop"]:
            for mp in managed:
                rc = mp.proc.poll()
                if rc is not None:
                    print(f"[gateway] service '{mp.name}' exited with code {rc}")
                    logger.error("gateway_service_exited name=%s rc=%d", mp.name, rc)
                    _terminate_managed(managed)
                    return rc if rc != 0 else 1
            time.sleep(0.4)
    finally:
        _terminate_managed(managed)

    return 0


def _run_both(host: str, port: int, reload: bool, term_args: list[str]) -> None:
    cmd = [sys.executable, "opensift.py", "ui", "--host", host, "--port", str(port)]
    if reload:
        cmd.append("--reload")

    ui_proc = subprocess.Popen(cmd)
    print(f"\nStarted UI at http://{host}:{port} (pid={ui_proc.pid})")
    print("Starting terminal chat. When terminal exits, UI process will stop.\n")

    try:
        run_terminal(term_args)
    finally:
        ui_proc.terminate()
        try:
            ui_proc.wait(timeout=5)
        except Exception:
            ui_proc.kill()


def run_setup(skip_key_prompts: bool = False) -> None:
    env_path = os.path.join(os.getcwd(), ".env")
    env_data = _parse_env_file(env_path)

    print("\nOpenSift Setup Wizard")
    print("=" * 72)
    print("This will configure API/token keys and optionally launch OpenSift.\n")

    updated = dict(env_data)
    if not skip_key_prompts:
        key_specs = [
            ("OPENAI_API_KEY", "OpenAI API key (optional)"),
            ("ANTHROPIC_API_KEY", "Anthropic API key (optional)"),
            ("CLAUDE_CODE_OAUTH_TOKEN", "Claude Code OAuth token (optional)"),
            ("CHATGPT_CODEX_OAUTH_TOKEN", "ChatGPT Codex OAuth token (optional)"),
            ("OPENSIFT_CLAUDE_CODE_CMD", "Claude Code command (default: claude)"),
            ("OPENSIFT_CLAUDE_CODE_ARGS", "Claude Code extra args (optional)"),
            ("OPENSIFT_CODEX_CMD", "Codex command (default: codex)"),
            ("OPENSIFT_CODEX_ARGS", "Codex extra args (optional)"),
        ]

        for key, label in key_specs:
            secret = key not in (
                "OPENSIFT_CLAUDE_CODE_CMD",
                "OPENSIFT_CLAUDE_CODE_ARGS",
                "OPENSIFT_CODEX_CMD",
                "OPENSIFT_CODEX_ARGS",
            )
            current = updated.get(key, "")
            value = _prompt_value(label, current=current, secret=secret)
            if value is None:
                continue
            if value == "":
                updated.pop(key, None)
            else:
                updated[key] = value

        _write_env_file(env_path, updated)
        print(f"\nSaved environment config: {env_path}")
    else:
        print("\nSkipping key prompts (using existing .env values).")

    _apply_env(updated)
    codex_cmd = (updated.get("OPENSIFT_CODEX_CMD") or "codex").strip()
    if updated.get("CHATGPT_CODEX_OAUTH_TOKEN") and _cmd_looks_like_wrong_codex(codex_cmd):
        print("\n⚠️ Codex command validation warning:")
        print(f"   '{codex_cmd}' appears to be the unrelated npm 'codex' package (site generator).")
        print("   Install the ChatGPT Codex CLI and set OPENSIFT_CODEX_CMD to the correct executable.")

    print("\nLaunch mode options:")
    print("  - ui       : Web chatbot (FastAPI UI)")
    print("  - terminal : Terminal chatbot")
    print("  - gateway  : Supervised gateway (UI + optional MCP)")
    print("  - both     : Start UI + terminal together")
    print("  - none     : Exit setup without launching")
    print("\nNote: ChatGPT Codex OAuth is captured for local Codex CLI integrations.")

    mode = _prompt_choice("Choose launch mode", ["ui", "terminal", "gateway", "both", "none"], default="gateway")
    if mode == "none":
        print("Setup complete.")
        return

    host = input("UI host (default: 127.0.0.1): ").strip() or "127.0.0.1"
    port_raw = input("UI port (default: 8001): ").strip() or "8001"
    try:
        port = int(port_raw)
    except ValueError:
        port = 8001
    reload = _prompt_choice("Enable auto-reload", ["y", "n"], default="y") == "y"

    provider_default = "claude_code"
    if updated.get("ANTHROPIC_API_KEY"):
        provider_default = "claude"
    elif updated.get("OPENAI_API_KEY"):
        provider_default = "openai"
    elif (updated.get("CHATGPT_CODEX_OAUTH_TOKEN") or _codex_auth_file_token()):
        provider_default = "codex"
    elif updated.get("CLAUDE_CODE_OAUTH_TOKEN"):
        provider_default = "claude_code"

    provider = _prompt_choice(
        "Terminal provider",
        ["openai", "claude", "claude_code", "codex"],
        default=provider_default,
    )
    term_args = _terminal_args_for_provider(provider)

    if mode == "ui":
        run_ui(host, port, reload)
        return
    if mode == "terminal":
        run_terminal(term_args)
        return
    if mode == "gateway":
        with_mcp = _prompt_choice("Launch MCP server too", ["y", "n"], default="y") == "y"
        rc = run_gateway(host=host, port=port, reload=reload, with_mcp=with_mcp, health_timeout=20.0)
        raise SystemExit(rc)
    _run_both(host, port, reload, term_args)


def main() -> None:
    parser = argparse.ArgumentParser(description="OpenSift Launcher (UI, Terminal, Gateway)")
    parser.add_argument("--version", action="version", version=f"OpenSift {OPENSIFT_VERSION}")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_setup = sub.add_parser("setup", help="Interactive setup wizard for keys + launch mode")
    p_setup.add_argument(
        "--skip-key-prompts",
        action="store_true",
        help="Skip key/token prompts and use existing values from .env",
    )

    p_ui = sub.add_parser("ui", help="Run localhost web UI")
    p_ui.add_argument("--host", default="127.0.0.1", help="Bind host (default: 127.0.0.1)")
    p_ui.add_argument("--port", type=int, default=8001, help="Port (default: 8001)")
    p_ui.add_argument("--reload", action="store_true", help="Enable auto-reload")

    p_term = sub.add_parser("terminal", help="Run terminal chatbot")
    p_term.add_argument("--owner", default="default", help="Owner/namespace")
    p_term.add_argument("--mode", default="study_guide", help="Mode")
    p_term.add_argument("--provider", default="claude_code", choices=["openai", "claude", "claude_code", "codex"])
    p_term.add_argument("--model", default="", help="Model override (optional)")
    p_term.add_argument("--k", type=int, default=8, help="Top-k retrieval")
    p_term.add_argument("--wrap", type=int, default=100, help="Wrap width")
    p_term.add_argument("--history-turns", type=int, default=10, help="How many messages to include as history")
    p_term.add_argument("--no-stream", action="store_true", help="Disable streaming output")
    p_term.add_argument("--no-sources", action="store_true", help="Disable sources printing")

    p_gateway = sub.add_parser("gateway", help="Run supervised OpenSift gateway (UI + optional MCP)")
    p_gateway.add_argument("--host", default="127.0.0.1", help="UI bind host (default: 127.0.0.1)")
    p_gateway.add_argument("--port", type=int, default=8001, help="UI port (default: 8001)")
    p_gateway.add_argument("--reload", action="store_true", help="Enable UI auto-reload")
    p_gateway.add_argument("--with-mcp", action="store_true", help="Also launch MCP server")
    p_gateway.add_argument("--health-timeout", type=float, default=20.0, help="Seconds to wait for UI health")

    args, extras = parser.parse_known_args()

    this_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(this_dir)

    if args.cmd == "setup":
        logger.info("launcher_cmd setup skip_key_prompts=%s", bool(getattr(args, "skip_key_prompts", False)))
        run_setup(skip_key_prompts=bool(getattr(args, "skip_key_prompts", False)))
        return

    if args.cmd == "ui":
        logger.info("launcher_cmd ui host=%s port=%d reload=%s", args.host, args.port, args.reload)
        run_ui(args.host, args.port, args.reload)
        return

    if args.cmd == "gateway":
        logger.info(
            "launcher_cmd gateway host=%s port=%d reload=%s with_mcp=%s health_timeout=%.1f",
            args.host,
            args.port,
            args.reload,
            args.with_mcp,
            args.health_timeout,
        )
        rc = run_gateway(
            host=args.host,
            port=args.port,
            reload=args.reload,
            with_mcp=args.with_mcp,
            health_timeout=args.health_timeout,
        )
        raise SystemExit(rc)

    if args.cmd == "terminal":
        logger.info("launcher_cmd terminal owner=%s mode=%s provider=%s", args.owner, args.mode, args.provider)
        forwarded = [
            "--owner",
            args.owner,
            "--mode",
            args.mode,
            "--provider",
            args.provider,
            "--model",
            args.model,
            "--k",
            str(args.k),
            "--wrap",
            str(args.wrap),
            "--history-turns",
            str(args.history_turns),
        ]
        if args.no_stream:
            forwarded.append("--no-stream")
        if args.no_sources:
            forwarded.append("--no-sources")

        run_terminal(forwarded + extras)
        return


if __name__ == "__main__":
    main()
