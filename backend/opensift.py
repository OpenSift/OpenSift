from __future__ import annotations

import argparse
import getpass
import os
import subprocess
import sys
from typing import Dict, Optional


def run_ui(host: str, port: int, reload: bool) -> None:
    import uvicorn  # type: ignore

    uvicorn.run(
        "ui_app:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info",
    )


def run_terminal(argv: list[str]) -> None:
    from cli_chat import main as cli_main  # type: ignore

    old_argv = sys.argv[:]
    try:
        sys.argv = ["cli_chat.py", *argv]
        cli_main()
    finally:
        sys.argv = old_argv


def _parse_env_file(path: str) -> Dict[str, str]:
    data: Dict[str, str] = {}
    if not os.path.exists(path):
        return data

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            key, value = line.split("=", 1)
            data[key.strip()] = value.strip()
    return data


def _write_env_file(path: str, values: Dict[str, str]) -> None:
    lines = [
        "# OpenSift local environment",
        "# Generated by: python opensift.py setup",
        "",
    ]
    for key in sorted(values.keys()):
        val = values[key].replace("\n", "\\n")
        lines.append(f"{key}={val}")
    lines.append("")

    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))


def _mask(value: str) -> str:
    if not value:
        return "(not set)"
    if len(value) <= 8:
        return "*" * len(value)
    return f"{value[:4]}...{value[-4:]}"


def _prompt_value(label: str, current: str, secret: bool = True) -> Optional[str]:
    shown = _mask(current)
    print(f"\n{label}")
    print(f"Current: {shown}")
    print("Leave blank to keep current value. Type 'none' to clear.")
    prompt = "New value: "
    raw = getpass.getpass(prompt) if secret else input(prompt)
    value = raw.strip()

    if value == "":
        return None
    if value.lower() == "none":
        return ""
    return value


def _prompt_choice(label: str, choices: list[str], default: str) -> str:
    joined = "/".join(choices)
    while True:
        raw = input(f"{label} [{joined}] (default: {default}): ").strip().lower()
        if not raw:
            return default
        if raw in choices:
            return raw
        print(f"Please choose one of: {joined}")


def _apply_env(values: Dict[str, str]) -> None:
    for key, val in values.items():
        if val:
            os.environ[key] = val
        else:
            os.environ.pop(key, None)


def _terminal_args_for_provider(provider: str) -> list[str]:
    return ["--provider", provider]


def _run_both(host: str, port: int, reload: bool, term_args: list[str]) -> None:
    cmd = [sys.executable, "opensift.py", "ui", "--host", host, "--port", str(port)]
    if reload:
        cmd.append("--reload")

    ui_proc = subprocess.Popen(cmd)
    print(f"\nStarted UI at http://{host}:{port} (pid={ui_proc.pid})")
    print("Starting terminal chat. When terminal exits, UI process will stop.\n")

    try:
        run_terminal(term_args)
    finally:
        ui_proc.terminate()
        try:
            ui_proc.wait(timeout=5)
        except Exception:
            ui_proc.kill()


def run_setup() -> None:
    env_path = os.path.join(os.getcwd(), ".env")
    env_data = _parse_env_file(env_path)

    print("\nOpenSift Setup Wizard")
    print("=" * 72)
    print("This will configure API/token keys and optionally launch OpenSift.\n")

    key_specs = [
        ("OPENAI_API_KEY", "OpenAI API key (optional)"),
        ("ANTHROPIC_API_KEY", "Anthropic API key (optional)"),
        ("CLAUDE_CODE_OAUTH_TOKEN", "Claude Code OAuth token (optional)"),
        ("OPENSIFT_CLAUDE_CODE_CMD", "Claude Code command (default: claude)"),
        ("OPENSIFT_CLAUDE_CODE_ARGS", "Claude Code extra args (optional)"),
    ]

    updated = dict(env_data)
    for key, label in key_specs:
        secret = key not in ("OPENSIFT_CLAUDE_CODE_CMD", "OPENSIFT_CLAUDE_CODE_ARGS")
        current = updated.get(key, "")
        value = _prompt_value(label, current=current, secret=secret)
        if value is None:
            continue
        if value == "":
            updated.pop(key, None)
        else:
            updated[key] = value

    _write_env_file(env_path, updated)
    _apply_env(updated)

    print(f"\nSaved environment config: {env_path}")
    print("\nLaunch mode options:")
    print("  - ui       : Web chatbot (FastAPI UI)")
    print("  - terminal : Terminal chatbot")
    print("  - both     : Start UI + terminal together")
    print("  - none     : Exit setup without launching")

    mode = _prompt_choice("Choose launch mode", ["ui", "terminal", "both", "none"], default="ui")
    if mode == "none":
        print("Setup complete.")
        return

    host = input("UI host (default: 127.0.0.1): ").strip() or "127.0.0.1"
    port_raw = input("UI port (default: 8001): ").strip() or "8001"
    try:
        port = int(port_raw)
    except ValueError:
        port = 8001
    reload = _prompt_choice("Enable auto-reload", ["y", "n"], default="y") == "y"

    provider_default = "claude_code"
    if updated.get("ANTHROPIC_API_KEY"):
        provider_default = "claude"
    elif updated.get("OPENAI_API_KEY"):
        provider_default = "openai"
    elif updated.get("CLAUDE_CODE_OAUTH_TOKEN"):
        provider_default = "claude_code"

    provider = _prompt_choice(
        "Terminal provider",
        ["openai", "claude", "claude_code"],
        default=provider_default,
    )
    term_args = _terminal_args_for_provider(provider)

    if mode == "ui":
        run_ui(host, port, reload)
        return
    if mode == "terminal":
        run_terminal(term_args)
        return
    _run_both(host, port, reload, term_args)


def main() -> None:
    parser = argparse.ArgumentParser(description="OpenSift Launcher (UI or Terminal)")
    sub = parser.add_subparsers(dest="cmd", required=True)

    sub.add_parser("setup", help="Interactive setup wizard for keys + launch mode")

    p_ui = sub.add_parser("ui", help="Run localhost web UI")
    p_ui.add_argument("--host", default="127.0.0.1", help="Bind host (default: 127.0.0.1)")
    p_ui.add_argument("--port", type=int, default=8001, help="Port (default: 8001)")
    p_ui.add_argument("--reload", action="store_true", help="Enable auto-reload")

    p_term = sub.add_parser("terminal", help="Run terminal chatbot")
    p_term.add_argument("--owner", default="default", help="Owner/namespace")
    p_term.add_argument("--mode", default="study_guide", help="Mode")
    p_term.add_argument("--provider", default="claude_code", choices=["openai", "claude", "claude_code"])
    p_term.add_argument("--model", default="", help="Model override (optional)")
    p_term.add_argument("--k", type=int, default=8, help="Top-k retrieval")
    p_term.add_argument("--wrap", type=int, default=100, help="Wrap width")
    p_term.add_argument("--history-turns", type=int, default=10, help="How many messages to include as history")
    p_term.add_argument("--no-stream", action="store_true", help="Disable streaming output")
    p_term.add_argument("--no-sources", action="store_true", help="Disable sources printing")

    args, extras = parser.parse_known_args()

    this_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(this_dir)

    if args.cmd == "setup":
        run_setup()
        return

    if args.cmd == "ui":
        run_ui(args.host, args.port, args.reload)
        return

    if args.cmd == "terminal":
        forwarded = [
            "--owner",
            args.owner,
            "--mode",
            args.mode,
            "--provider",
            args.provider,
            "--model",
            args.model,
            "--k",
            str(args.k),
            "--wrap",
            str(args.wrap),
            "--history-turns",
            str(args.history_turns),
        ]
        if args.no_stream:
            forwarded.append("--no-stream")
        if args.no_sources:
            forwarded.append("--no-sources")

        run_terminal(forwarded + extras)
        return


if __name__ == "__main__":
    main()
