<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>OpenSift Chat</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: #121a30;
        --panel-2: #16223d;
        --text: #e9eefc;
        --muted: #97a6c9;
        --line: rgba(255, 255, 255, 0.12);
        --brand: #4f74ff;
        --danger: #c85b5b;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        color: var(--text);
        font-family: "Sohne", "Inter", "Avenir Next", "Segoe UI", sans-serif;
        background:
          radial-gradient(1200px 700px at -20% -25%, #2b3f84 0%, transparent 56%),
          radial-gradient(900px 540px at 130% -10%, #20416b 0%, transparent 58%),
          linear-gradient(180deg, #080c16 0%, #0b1020 100%);
      }
      .app {
        height: 100vh;
        display: grid;
        grid-template-columns: 320px 1fr;
      }
      .sidebar {
        border-right: 1px solid var(--line);
        background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
        display: grid;
        grid-template-rows: auto auto auto 1fr auto;
        min-height: 0;
      }
      .section {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
      }
      .brand {
        font-size: 18px;
        font-weight: 650;
      }
      .newchat-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      .history-wrap { min-height: 0; overflow: auto; padding: 10px; }
      .history-list { display: grid; gap: 8px; }
      .ingest-stack { display: grid; gap: 8px; }
      .out {
        border: 1px dashed var(--line);
        border-radius: 10px;
        padding: 8px;
        white-space: pre-wrap;
        font-size: 12px;
        background: rgba(0,0,0,.15);
        color: var(--muted);
      }
      .session-item {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        background: rgba(255,255,255,.02);
      }
      .session-item-title { font-size: 13px; font-weight: 600; }
      .session-item-meta { font-size: 11px; color: var(--muted); margin-top: 4px; }
      .session-item-actions { margin-top: 8px; display: flex; gap: 6px; }
      .main { min-width: 0; display: grid; grid-template-rows: auto 1fr; }
      .topbar {
        border-bottom: 1px solid var(--line);
        padding: 10px 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .pill {
        font-size: 11px;
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 6px 10px;
        color: var(--muted);
      }
      .chat-zone { min-height: 0; display: grid; grid-template-rows: 1fr auto; }
      .chat-scroll { min-height: 0; overflow: auto; padding: 16px 22px 8px; }
      .msg { display: flex; margin: 10px 0; }
      .msg.user { justify-content: flex-end; }
      .bubble {
        max-width: min(860px, 82%);
        border: 1px solid transparent;
        border-radius: 14px;
        padding: 11px 13px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .user .bubble { background: linear-gradient(180deg, #5a76ff, #4564ff); color: #fff; }
      .assistant .bubble { background: var(--panel); border-color: var(--line); }
      .meta { margin-top: 7px; font-size: 11px; color: var(--muted); }
      .composer {
        border-top: 1px solid var(--line);
        padding: 12px 14px;
        display: grid;
        gap: 9px;
        background: rgba(10,15,26,.94);
      }
      .controls { display: grid; grid-template-columns: 1fr 1fr .7fr 1.2fr 120px; gap: 8px; }
      .toggle-row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
      .toggle-row label { font-size: 12px; color: var(--muted); display: inline-flex; gap: 6px; align-items: center; }
      .toggle-row input { width: auto; }
      input, select, textarea, button {
        font: inherit;
      }
      input, select, textarea {
        width: 100%;
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(255,255,255,.04);
        padding: 9px 10px;
      }
      textarea { min-height: 64px; resize: vertical; }
      button {
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(255,255,255,.05);
        padding: 9px 10px;
        cursor: pointer;
      }
      button.primary { background: linear-gradient(180deg, #5a76ff, #4564ff); border-color: var(--brand); }
      button.danger { background: rgba(200, 91, 91, .2); border-color: rgba(200, 91, 91, .4); }
      .hint { font-size: 11px; color: var(--muted); }
      @media (max-width: 900px) {
        .app { grid-template-columns: 1fr; }
        .controls { grid-template-columns: 1fr 1fr; }
      }
    </style>
  </head>
  <body data-csrf="{{ csrf_token }}">
    <div class="app">
      <aside class="sidebar">
        <div class="section"><div class="brand">OpenSift Chat</div></div>

        <div class="section" style="display:flex; gap:8px;">
          <button id="refreshHistoryBtn" type="button" style="width:100%;">Refresh</button>
          <button id="settingsBtn" type="button" style="width:100%;">Settings</button>
        </div>

        <div class="section">
          <label for="newChatName" class="hint">New Chat Name (optional)</label>
          <div class="newchat-row">
            <input id="newChatName" placeholder="bio302-midterm" />
            <button id="newChatBtn" type="button" class="primary">New</button>
          </div>
        </div>

        <div class="section">
          <label for="owner" class="hint">Current Owner</label>
          <input id="owner" value="{{ owner }}" placeholder="bio101" />
        </div>

        <div class="section">
          <div class="hint" style="margin-bottom:6px;">Ingest Material</div>
          <div class="ingest-stack">
            <input id="ingestTitle" placeholder="Source title (optional)" />
            <input id="ingestUrl" placeholder="https://example.com/article" />
            <button id="ingestUrlBtn" type="button">Ingest URL</button>
            <input id="ingestFile" type="file" />
            <button id="ingestFileBtn" type="button">Upload + Ingest</button>
            <div class="out" id="ingestOut">No ingest action yet.</div>
          </div>
        </div>

        <div class="history-wrap">
          <div class="hint" style="margin:2px 4px 8px;">Conversation History</div>
          <div class="history-list" id="historyList"></div>
        </div>

        <div class="section" style="display:flex; gap:8px; border-top:1px solid var(--line);">
          <button id="clearBtn" type="button" class="danger" style="width:100%;">Clear</button>
          <button id="logoutBtn" type="button" style="width:100%;">Logout</button>
        </div>
      </aside>

      <main class="main">
        <div class="topbar">
          <span class="pill">owner: <strong id="ownerLabel">{{ owner }}</strong></span>
          <span class="pill" id="busy" style="display:none;">Working...</span>
        </div>

        <div class="chat-zone">
          <div class="chat-scroll" id="chat">
            {% for m in history %}
              <div class="msg {{ m.role }}">
                <div class="bubble">
                  {{ m.text }}
                  <div class="meta">{{ m.ts }}</div>
                </div>
              </div>
            {% endfor %}
          </div>

          <div class="composer">
            <div class="controls">
              <select id="mode">
                <option value="study_guide">Study Guide</option>
                <option value="key_points">Key Points</option>
                <option value="quiz">Quiz</option>
              </select>
              <select id="provider">
                <option value="claude_code" {% if preferred_provider == "claude_code" %}selected{% endif %} {% if not provider_caps.claude_code_ready %}disabled{% endif %}>
                  Claude Code{% if not provider_caps.claude_code_cli_available and provider_caps.anthropic_api_key_set %} (Claude API fallback){% elif not provider_caps.claude_code_ready %} (unavailable in container){% endif %}
                </option>
                <option value="codex" {% if preferred_provider == "codex" %}selected{% endif %} {% if not provider_caps.codex_ready %}disabled{% endif %}>
                  ChatGPT Codex{% if not provider_caps.codex_cli_available and provider_caps.openai_api_key_set %} (OpenAI fallback){% elif not provider_caps.codex_ready %} (unavailable in container){% endif %}
                </option>
                <option value="claude" {% if preferred_provider == "claude" %}selected{% endif %} {% if not provider_caps.claude_ready %}disabled{% endif %}>
                  Claude API{% if not provider_caps.claude_ready %} (key required){% endif %}
                </option>
                <option value="openai" {% if preferred_provider == "openai" %}selected{% endif %} {% if not provider_caps.openai_ready %}disabled{% endif %}>
                  OpenAI{% if not provider_caps.openai_ready %} (key required){% endif %}
                </option>
              </select>
              <input id="k" type="number" value="8" min="1" max="20" />
              <select id="model">
                <option value="" selected>Auto model</option>
                {% for m in supported_claude_models %}
                  <option value="{{ m }}">{{ m }}</option>
                {% endfor %}
                {% for m in supported_openai_models %}
                  <option value="{{ m }}">{{ m }}</option>
                {% endfor %}
              </select>
              <button id="sendBtn" type="button" class="primary">Send</button>
            </div>

            <div class="toggle-row">
              <label><input id="thinkingEnabled" type="checkbox" /> Enable thinking</label>
              <label>Thinking level
                <select id="thinkingLevel" style="width:auto; min-width:130px;">
                  {% for lvl in supported_thinking_levels %}
                    <option value="{{ lvl }}" {% if lvl == "medium" %}selected{% endif %}>{{ lvl }}</option>
                  {% endfor %}
                </select>
              </label>
              <label><input id="showThinking" type="checkbox" checked /> Show thinking/status</label>
              <label><input id="trueStreaming" type="checkbox" checked /> True streaming</label>
            </div>

            <textarea id="msg" placeholder="Ask OpenSift... (Shift+Enter newline)"></textarea>
            {% if not provider_caps.any_provider_ready %}
            <div class="hint">
              No LLM provider is ready in this container. Install `claude`/`codex` inside the image, or set `ANTHROPIC_API_KEY` / `OPENAI_API_KEY` in `/app/.env`.
            </div>
            {% endif %}
            <div class="hint">Enter sends. Shift+Enter for newline.</div>
          </div>
        </div>
      </main>
    </div>

    <script>
      const chat = document.getElementById("chat");
      const ownerEl = document.getElementById("owner");
      const ownerLabel = document.getElementById("ownerLabel");
      const msgEl = document.getElementById("msg");
      const modeEl = document.getElementById("mode");
      const providerEl = document.getElementById("provider");
      const kEl = document.getElementById("k");
      const modelEl = document.getElementById("model");
      const thinkingEnabledEl = document.getElementById("thinkingEnabled");
      const thinkingLevelEl = document.getElementById("thinkingLevel");
      const showThinkingEl = document.getElementById("showThinking");
      const trueStreamingEl = document.getElementById("trueStreaming");

      const sendBtn = document.getElementById("sendBtn");
      const clearBtn = document.getElementById("clearBtn");
      const logoutBtn = document.getElementById("logoutBtn");
      const settingsBtn = document.getElementById("settingsBtn");
      const newChatBtn = document.getElementById("newChatBtn");
      const newChatNameEl = document.getElementById("newChatName");
      const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
      const historyList = document.getElementById("historyList");
      const ingestTitleEl = document.getElementById("ingestTitle");
      const ingestUrlEl = document.getElementById("ingestUrl");
      const ingestUrlBtn = document.getElementById("ingestUrlBtn");
      const ingestFileEl = document.getElementById("ingestFile");
      const ingestFileBtn = document.getElementById("ingestFileBtn");
      const ingestOutEl = document.getElementById("ingestOut");
      const busy = document.getElementById("busy");
      const csrfToken = document.body.dataset.csrf || "";

      function csrfFetch(url, options = {}) {
        const headers = new Headers(options.headers || {});
        headers.set("X-CSRF-Token", csrfToken);
        return fetch(url, { ...options, headers });
      }

      async function ensureAuth(res) {
        if (res.status === 401 || res.status === 403) {
          window.location.href = "/login";
          return false;
        }
        return true;
      }

      function setBusy(on) { busy.style.display = on ? "inline" : "none"; }
      function scrollToBottom() { chat.scrollTop = chat.scrollHeight; }

      function owner() {
        const raw = ownerEl.value.trim() || "default";
        const normalized = raw.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 128) || "default";
        ownerEl.value = normalized;
        ownerLabel.textContent = normalized;
        return normalized;
      }

      function addBubble(role, text, ts) {
        const row = document.createElement("div");
        row.className = "msg " + role;
        const bubble = document.createElement("div");
        bubble.className = "bubble";
        const textNode = document.createElement("div");
        textNode.textContent = text || "";
        bubble.appendChild(textNode);
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = ts || "";
        bubble.appendChild(meta);
        row.appendChild(bubble);
        chat.appendChild(row);
        scrollToBottom();
        return { textEl: textNode, bubbleEl: bubble };
      }

      function normalizeProviderAndModel(provider, model) {
        const p = (provider || "").trim().toLowerCase();
        const m = (model || "").trim();
        if (!m) return { provider: p, model: m, note: "" };
        const isClaudeModel = m.startsWith("claude-");
        const isGptModel = m.startsWith("gpt-");
        if ((p === "codex" || p === "openai") && isClaudeModel) {
          return {
            provider: p,
            model: "",
            note: `Model '${m}' is Claude-family and not valid for ${p}; using Auto model instead.`,
          };
        }
        if ((p === "claude" || p === "claude_code") && isGptModel) {
          return {
            provider: p,
            model: "",
            note: `Model '${m}' is GPT-family and not valid for ${p}; using Auto model instead.`,
          };
        }
        return { provider: p, model: m, note: "" };
      }

      function renderHistory(messages) {
        chat.innerHTML = "";
        for (const m of messages || []) addBubble(m.role || "assistant", m.text || "", m.ts || "");
      }

      async function sendStream() {
        const o = owner();
        const message = msgEl.value.trim();
        if (!message) return;

        addBubble("user", message, new Date().toISOString());
        msgEl.value = "";
        sendBtn.disabled = true;
        setBusy(true);

        const a = addBubble("assistant", "", new Date().toISOString());
        const statusEl = document.createElement("div");
        statusEl.className = "hint";
        statusEl.style.marginBottom = "6px";
        a.bubbleEl.insertBefore(statusEl, a.textEl);
        const statusLogEl = document.createElement("div");
        statusLogEl.className = "hint";
        statusLogEl.style.whiteSpace = "pre-wrap";
        statusLogEl.style.fontSize = "12px";
        statusLogEl.style.opacity = "0.9";
        statusLogEl.style.marginBottom = "6px";
        a.bubbleEl.insertBefore(statusLogEl, a.textEl);
        const statusLines = [];
        const pushStatus = (text) => {
          const line = (text || "").trim();
          if (!line) return;
          const stamped = `[${new Date().toLocaleTimeString()}] ${line}`;
          statusLines.push(stamped);
          if (statusLines.length > 10) statusLines.shift();
          statusLogEl.textContent = statusLines.join("\n");
        };

        const form = new FormData();
        form.append("owner", o);
        form.append("message", message);
        form.append("mode", modeEl.value);
        const normalized = normalizeProviderAndModel(providerEl.value, modelEl.value);
        form.append("provider", normalized.provider || providerEl.value);
        form.append("k", kEl.value);
        form.append("model", normalized.model);
        form.append("thinking_enabled", thinkingEnabledEl.checked ? "true" : "false");
        form.append("thinking_level", thinkingLevelEl.value || "medium");
        form.append("show_thinking", showThinkingEl.checked ? "true" : "false");
        form.append("true_streaming", trueStreamingEl.checked ? "true" : "false");
        if (normalized.note) {
          statusEl.textContent = normalized.note;
          pushStatus(normalized.note);
        }

        const controller = new AbortController();
        const timeoutMs = 600000;
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const res = await csrfFetch("/chat/stream", { method: "POST", body: form, signal: controller.signal });
          if (!(await ensureAuth(res))) return;
          if (!res.ok || !res.body) {
            a.textEl.textContent = "Streaming failed to start.";
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let idx;
            while ((idx = buffer.indexOf("\n")) >= 0) {
              const line = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 1);
              if (!line) continue;
              let evt;
              try { evt = JSON.parse(line); } catch { continue; }
              if (evt.type === "delta") a.textEl.textContent += (evt.text || "");
              if (evt.type === "status" && showThinkingEl.checked) {
                statusEl.textContent = evt.text || "";
                pushStatus(evt.text || "");
              }
              if (evt.type === "error") {
                const msg = evt.message || "Request failed.";
                a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + `⚠️ ${msg}`;
                pushStatus(`Error: ${msg}`);
              }
              if (evt.type === "done") statusEl.textContent = "Completed.";
              scrollToBottom();
            }
          }
        } catch (err) {
          let recovered = false;
          try {
            const exp = await fetch(`/chat/session/export?owner=${encodeURIComponent(o)}`);
            if (exp.ok) {
              const data = await exp.json();
              const hist = data.history || [];
              for (let i = hist.length - 1; i >= 0; i--) {
                const m = hist[i];
                if (m && m.role === "assistant" && (m.text || "").trim()) {
                  a.textEl.textContent = m.text || "";
                  recovered = true;
                  break;
                }
              }
            }
          } catch (_) {}
          if (recovered) {
            statusEl.textContent = "Recovered from session cache.";
            pushStatus("Recovered from session cache.");
            return;
          }
          if (controller.signal.aborted) {
            const t = "⚠️ Request timed out while loading/retrieving. Please retry.";
            a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + t;
            pushStatus(t);
          } else {
            const t = "⚠️ Streaming interrupted. If this happened during first-run embedding download, retry once warmup completes.";
            a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + t;
            pushStatus(t);
          }
          statusEl.textContent = "Failed.";
        } finally {
          clearTimeout(timeoutId);
          sendBtn.disabled = false;
          setBusy(false);
          await loadSessions();
        }
      }

      async function clearChat() {
        const form = new FormData();
        form.append("owner", owner());
        const res = await csrfFetch("/chat/clear", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        chat.innerHTML = "";
        await loadSessions();
      }

      async function logout() {
        await csrfFetch("/logout", { method: "POST" });
        window.location.href = "/login";
      }

      async function loadSessions() {
        const res = await fetch("/chat/session/list");
        if (!(await ensureAuth(res))) return;
        if (!res.ok) return;
        const data = await res.json();
        const sessions = data.sessions || [];

        historyList.innerHTML = "";
        if (!sessions.length) {
          const hint = document.createElement("div");
          hint.className = "hint";
          hint.textContent = "No chats yet.";
          historyList.appendChild(hint);
          return;
        }

        for (const s of sessions) {
          const card = document.createElement("div");
          card.className = "session-item";

          const t = document.createElement("div");
          t.className = "session-item-title";
          t.textContent = s.owner || "";
          card.appendChild(t);

          const m = document.createElement("div");
          m.className = "session-item-meta";
          m.textContent = `${s.count || 0} msgs · ${s.last_ts || ""}`;
          card.appendChild(m);

          const actions = document.createElement("div");
          actions.className = "session-item-actions";

          const openBtn = document.createElement("button");
          openBtn.type = "button";
          openBtn.textContent = "Open";
          openBtn.addEventListener("click", () => openSession(s.owner));

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "danger";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", () => deleteSessionByOwner(s.owner));

          actions.appendChild(openBtn);
          actions.appendChild(delBtn);
          card.appendChild(actions);
          historyList.appendChild(card);
        }
      }

      async function openSession(ownerName) {
        ownerEl.value = ownerName;
        owner();
        const res = await fetch(`/chat/session/export?owner=${encodeURIComponent(ownerName)}`);
        if (!(await ensureAuth(res))) return;
        if (!res.ok) return;
        const data = await res.json();
        renderHistory(data.history || []);
      }

      async function deleteSessionByOwner(ownerName) {
        const form = new FormData();
        form.append("owner", ownerName);
        const res = await csrfFetch("/chat/session/delete", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        if (owner() === ownerName) chat.innerHTML = "";
        await loadSessions();
      }

      async function startNewChat() {
        const typed = (newChatNameEl.value || "").trim();
        const d = new Date();
        const fallback = `chat-${d.getFullYear()}${String(d.getMonth()+1).padStart(2,"0")}${String(d.getDate()).padStart(2,"0")}-${String(d.getHours()).padStart(2,"0")}${String(d.getMinutes()).padStart(2,"0")}`;
        const nextOwner = typed || fallback;

        const form = new FormData();
        form.append("owner", nextOwner);
        const res = await csrfFetch("/chat/session/new", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;

        newChatNameEl.value = "";
        ownerEl.value = nextOwner;
        owner();
        chat.innerHTML = "";
        await loadSessions();
      }

      async function ingestUrl() {
        const url = (ingestUrlEl.value || "").trim();
        if (!url) return;
        ingestOutEl.textContent = "Ingesting URL...";
        const form = new FormData();
        form.append("owner", owner());
        form.append("url", url);
        form.append("source_title", (ingestTitleEl.value || "").trim());
        const res = await csrfFetch("/chat/ingest/url", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        const data = await res.json();
        ingestOutEl.textContent = data?.assistant?.text || `Ingest failed (HTTP ${res.status}).`;
      }

      async function ingestFile() {
        const file = ingestFileEl.files && ingestFileEl.files[0];
        if (!file) return;
        ingestOutEl.textContent = "Uploading + ingesting file...";
        const form = new FormData();
        form.append("owner", owner());
        form.append("file", file);
        const res = await csrfFetch("/chat/ingest/file", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        const data = await res.json();
        ingestOutEl.textContent = data?.assistant?.text || `File ingest failed (HTTP ${res.status}).`;
        ingestFileEl.value = "";
      }

      sendBtn.addEventListener("click", sendStream);
      clearBtn.addEventListener("click", clearChat);
      logoutBtn.addEventListener("click", logout);
      settingsBtn.addEventListener("click", () => {
        window.location.href = `/settings?owner=${encodeURIComponent(owner())}`;
      });
      refreshHistoryBtn.addEventListener("click", loadSessions);
      newChatBtn.addEventListener("click", startNewChat);
      ingestUrlBtn.addEventListener("click", ingestUrl);
      ingestFileBtn.addEventListener("click", ingestFile);
      newChatNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          startNewChat();
        }
      });
      ingestUrlEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          ingestUrl();
        }
      });
      ownerEl.addEventListener("change", async () => {
        owner();
        const res = await fetch(`/chat/session/export?owner=${encodeURIComponent(owner())}`);
        if (!(await ensureAuth(res))) return;
        if (res.ok) {
          const data = await res.json();
          renderHistory(data.history || []);
        }
      });
      msgEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendStream();
        }
      });

      owner();
      scrollToBottom();
      loadSessions();
    </script>
  </body>
</html>
