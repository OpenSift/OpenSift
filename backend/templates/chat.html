<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>OpenSift Chat</title>
    <style>
      :root {
        --bg: #f3f5f8;
        --panel: #ffffff;
        --panel-2: #f7f8fb;
        --text: #151a22;
        --muted: #6c7586;
        --line: #e4e8ef;
        --brand: #5aa8ff;
        --brand-soft: #eaf4ff;
        --danger: #c13737;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; overflow: hidden; }
      body {
        margin: 0;
        color: var(--text);
        font-family: "Manrope", "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
        background:
          radial-gradient(900px 500px at -15% -20%, #e8f3ff 0%, transparent 60%),
          radial-gradient(850px 500px at 120% -10%, #e6eefc 0%, transparent 58%),
          linear-gradient(180deg, #f6f8fb 0%, #f1f4f8 100%);
      }
      .app {
        height: 100dvh;
        display: grid;
        grid-template-columns: 300px 1fr;
        gap: 0;
        overflow: hidden;
      }
      .sidebar {
        border-right: 1px solid var(--line);
        background: linear-gradient(180deg, #fdfdfe, #f7f9fc);
        display: grid;
        grid-template-rows: auto auto auto 1fr auto;
        min-height: 0;
        overflow: hidden;
      }
      .section {
        padding: 12px;
        border-bottom: 1px solid var(--line);
      }
      .brand {
        font-size: 17px;
        font-weight: 760;
        letter-spacing: .02em;
      }
      .newchat-row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      .history-wrap { min-height: 0; overflow-y: auto; overflow-x: hidden; padding: 10px; }
      .history-list { display: grid; gap: 8px; }
      .ingest-stack { display: grid; gap: 8px; }
      .flashcards-stack { display: grid; gap: 8px; }
      .library-stack { display: grid; gap: 8px; }
      .out {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 9px;
        white-space: pre-wrap;
        font-size: 12px;
        background: var(--panel);
        color: var(--muted);
      }
      .session-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
        background: var(--panel);
        box-shadow: 0 1px 2px rgba(20, 29, 43, 0.06);
      }
      .session-item-title { font-size: 13px; font-weight: 600; }
      .session-item-meta { font-size: 11px; color: var(--muted); margin-top: 4px; }
      .session-item-actions { margin-top: 8px; display: flex; gap: 6px; }
      .fc-card {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
        background: var(--panel);
      }
      .fc-front { font-size: 13px; font-weight: 600; margin-bottom: 6px; }
      .fc-back {
        font-size: 12px;
        color: var(--muted);
        white-space: pre-wrap;
        margin-bottom: 6px;
      }
      .fc-meta { font-size: 11px; color: var(--muted); }
      .fc-actions {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .fc-actions button {
        padding: 6px 8px;
        font-size: 11px;
      }
      .main { min-width: 0; min-height: 0; display: grid; grid-template-rows: auto 1fr; overflow: hidden; }
      .topbar {
        border-bottom: 1px solid var(--line);
        padding: 10px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        background: var(--panel);
      }
      .pill {
        font-size: 11px;
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 6px 10px;
        color: var(--muted);
        background: #fff;
      }
      .chat-zone { min-height: 0; overflow: hidden; display: grid; grid-template-rows: 1fr auto; }
      .chat-scroll { min-height: 0; overflow-y: auto; overflow-x: hidden; padding: 18px 22px 10px; }
      .msg { display: flex; margin: 10px 0; }
      .msg.user { justify-content: flex-end; }
      .bubble {
        max-width: min(980px, 86%);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 12px 13px;
        white-space: pre-wrap;
        word-break: break-word;
        background: var(--panel);
        box-shadow: 0 1px 2px rgba(16, 24, 40, .05);
      }
      .user .bubble {
        background: linear-gradient(180deg, #f1f8ff, #e7f3ff);
        border-color: #cde5ff;
      }
      .assistant .bubble { background: var(--panel); }
      .meta { margin-top: 7px; font-size: 11px; color: var(--muted); }
      .composer {
        border-top: 1px solid var(--line);
        padding: 12px 14px;
        display: grid;
        gap: 9px;
        background: linear-gradient(180deg, #fafbfd, #f5f7fb);
      }
      .controls { display: grid; grid-template-columns: 1fr 1fr .7fr 1.2fr 120px; gap: 8px; }
      .toggle-row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
      .toggle-row label { font-size: 12px; color: var(--muted); display: inline-flex; gap: 6px; align-items: center; }
      .toggle-row input { width: auto; }
      input, select, textarea, button {
        font: inherit;
      }
      input, select, textarea {
        width: 100%;
        color: #1e2430;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 9px 10px;
      }
      textarea { min-height: 64px; resize: vertical; }
      button {
        color: #1b2230;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #fff;
        padding: 9px 10px;
        cursor: pointer;
      }
      button:hover { background: #f8fafc; }
      button.primary {
        background: linear-gradient(180deg, #68b2ff, #4f9dff);
        border-color: #438fe7;
        color: #fff;
      }
      button.danger {
        background: #fff1f1;
        border-color: #efb2b2;
        color: #9f2626;
      }
      .hint { font-size: 11px; color: var(--muted); }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(18, 24, 38, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        padding: 16px;
      }
      .modal-overlay.open { display: flex; }
      .modal {
        width: min(980px, 100%);
        max-height: 88vh;
        overflow: auto;
        border: 1px solid var(--line);
        border-radius: 14px;
        background: var(--panel);
        padding: 14px;
      }
      .modal-title { font-size: 16px; font-weight: 650; margin-bottom: 8px; }
      .modal-sub { font-size: 12px; color: var(--muted); margin-bottom: 10px; }
      .modal-actions { display: flex; gap: 8px; margin-top: 12px; }
      .modal-list { display: grid; gap: 8px; }
      .preview-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        background: var(--panel-2);
      }
      .preview-head { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
      .preview-head input { width: auto; }
      .preview-front { font-size: 13px; font-weight: 600; }
      .preview-back { font-size: 12px; color: var(--muted); white-space: pre-wrap; }
      .preview-fields { display: grid; gap: 6px; margin-top: 6px; }
      .preview-fields input,
      .preview-fields textarea {
        width: 100%;
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        padding: 7px 8px;
        font-size: 12px;
      }
      .preview-fields textarea {
        min-height: 84px;
        resize: vertical;
      }
      @media (max-width: 900px) {
        .app { grid-template-columns: 1fr; }
        .controls { grid-template-columns: 1fr 1fr; }
      }
    </style>
  </head>
  <body data-csrf="{{ csrf_token }}">
    <div class="app">
      <aside class="sidebar">
        <div class="section">
          <div class="brand">OpenSift</div>
          <div class="hint" style="margin-top:2px;">Gateway</div>
        </div>

        <div class="section" style="display:flex; gap:8px;">
          <button id="refreshHistoryBtn" type="button" style="width:100%;">Refresh</button>
          <button id="settingsBtn" type="button" style="width:100%;">Settings</button>
          <button id="libraryBtn" type="button" style="width:100%;">Library</button>
        </div>

        <div class="section">
          <label for="newChatName" class="hint">New Chat Name (optional)</label>
          <div class="newchat-row">
            <input id="newChatName" placeholder="bio302-midterm" />
            <button id="newChatBtn" type="button" class="primary">New</button>
          </div>
        </div>

        <div class="section">
          <label for="owner" class="hint">Current Owner</label>
          <input id="owner" value="{{ owner }}" placeholder="bio101" />
        </div>

        <div class="section">
          <div class="hint" style="margin-bottom:6px;">Ingest Material</div>
          <div class="ingest-stack">
            <input id="ingestTitle" placeholder="Source title (optional)" />
            <input id="ingestUrl" placeholder="https://example.com/article" />
            <button id="ingestUrlBtn" type="button">Ingest URL</button>
            <input id="ingestFile" type="file" />
            <button id="ingestFileBtn" type="button">Upload + Ingest</button>
            <div class="out" id="ingestOut">No ingest action yet.</div>
          </div>
        </div>

        <div class="section">
          <div class="hint" style="margin-bottom:6px;">Pinned Library Context</div>
          <div class="library-stack">
            <button id="selectLibraryBtn" type="button">Select Library Items</button>
            <div class="out" id="libraryCtxOut">No pinned library items.</div>
          </div>
        </div>

        <div class="section">
          <div class="hint" style="margin-bottom:6px;">Flashcards</div>
          <div class="flashcards-stack">
            <input id="flashFront" placeholder="Front (question/concept)" />
            <input id="flashBack" placeholder="Back (answer/explanation)" />
            <input id="flashTags" placeholder="Tags (comma-separated)" />
            <div style="display:flex; gap:8px;">
              <button id="flashAddBtn" type="button" class="primary" style="width:100%;">Add Card</button>
              <button id="flashFromReplyBtn" type="button" style="width:100%;">From Last Reply</button>
              <button id="flashRefreshBtn" type="button" style="width:100%;">Refresh</button>
            </div>
            <label class="hint"><input id="flashDueOnly" type="checkbox" /> Due only</label>
            <div class="out" id="flashOut">No flashcard action yet.</div>
            <div id="flashList" style="display:grid; gap:8px;"></div>
          </div>
        </div>

        <div class="history-wrap">
          <div class="hint" style="margin:2px 4px 8px;">Conversation History</div>
          <div class="history-list" id="historyList"></div>
        </div>

        <div class="section" style="display:flex; gap:8px; border-top:1px solid var(--line);">
          <button id="clearBtn" type="button" class="danger" style="width:100%;">Clear</button>
          <button id="logoutBtn" type="button" style="width:100%;">Logout</button>
        </div>
      </aside>

      <main class="main">
        <div class="topbar">
          <span class="pill">owner: <strong id="ownerLabel">{{ owner }}</strong></span>
          <span class="pill" id="busy" style="display:none;">Working...</span>
        </div>

        <div class="chat-zone">
          <div class="chat-scroll" id="chat">
            {% for m in history %}
              <div class="msg {{ m.role }}">
                <div class="bubble">
                  {{ m.text }}
                  <div class="meta">{{ m.ts }}</div>
                </div>
              </div>
            {% endfor %}
          </div>

          <div class="composer">
            <div class="controls">
              <select id="mode">
                <option value="study_guide">Study Guide</option>
                <option value="key_points">Key Points</option>
                <option value="quiz">Quiz</option>
              </select>
              <select id="provider">
                <option value="claude_code" {% if preferred_provider == "claude_code" %}selected{% endif %} {% if not provider_caps.claude_code_ready %}disabled{% endif %}>
                  Claude Code{% if not provider_caps.claude_code_cli_available and provider_caps.anthropic_api_key_set %} (Claude API fallback){% elif not provider_caps.claude_code_ready %} (unavailable in container){% endif %}
                </option>
                <option value="codex" {% if preferred_provider == "codex" %}selected{% endif %} {% if not provider_caps.codex_ready %}disabled{% endif %}>
                  ChatGPT Codex{% if not provider_caps.codex_cli_available and provider_caps.openai_api_key_set %} (OpenAI fallback){% elif not provider_caps.codex_ready %} (unavailable in container){% endif %}
                </option>
                <option value="claude" {% if preferred_provider == "claude" %}selected{% endif %} {% if not provider_caps.claude_ready %}disabled{% endif %}>
                  Claude API{% if not provider_caps.claude_ready %} (key required){% endif %}
                </option>
                <option value="openai" {% if preferred_provider == "openai" %}selected{% endif %} {% if not provider_caps.openai_ready %}disabled{% endif %}>
                  OpenAI{% if not provider_caps.openai_ready %} (key required){% endif %}
                </option>
              </select>
              <input id="k" type="number" value="8" min="1" max="20" />
              <select id="model">
                <option value="" selected>Auto model</option>
                {% for m in supported_claude_models %}
                  <option value="{{ m }}">{{ m }}</option>
                {% endfor %}
                {% for m in supported_openai_models %}
                  <option value="{{ m }}">{{ m }}</option>
                {% endfor %}
              </select>
              <button id="sendBtn" type="button" class="primary">Send</button>
            </div>

            <div class="toggle-row">
              <label><input id="thinkingEnabled" type="checkbox" /> Enable thinking</label>
              <label>Thinking level
                <select id="thinkingLevel" style="width:auto; min-width:130px;">
                  {% for lvl in supported_thinking_levels %}
                    <option value="{{ lvl }}" {% if lvl == "medium" %}selected{% endif %}>{{ lvl }}</option>
                  {% endfor %}
                </select>
              </label>
              <label><input id="showThinking" type="checkbox" checked /> Show thinking/status</label>
              <label><input id="trueStreaming" type="checkbox" checked /> True streaming</label>
            </div>

            <textarea id="msg" placeholder="Ask OpenSift... (Shift+Enter newline)"></textarea>
            {% if not provider_caps.any_provider_ready %}
            <div class="hint">
              No LLM provider is ready in this container. Install `claude`/`codex` inside the image, or set `ANTHROPIC_API_KEY` / `OPENAI_API_KEY` in `/app/.env`.
            </div>
            {% endif %}
            <div class="hint">Enter sends. Shift+Enter for newline.</div>
          </div>
        </div>
      </main>
    </div>
    <div id="flashPreviewModal" class="modal-overlay" aria-hidden="true">
      <div class="modal">
        <div class="modal-title">Create Flashcards Preview</div>
        <div class="modal-sub">Select the cards you want to create from the latest assistant reply.</div>
        <div id="flashPreviewList" class="modal-list"></div>
        <div class="modal-actions">
          <button id="flashPreviewCancelBtn" type="button">Cancel</button>
          <button id="flashPreviewCreateBtn" type="button" class="primary">Create Selected</button>
        </div>
      </div>
    </div>
    <div id="librarySelectModal" class="modal-overlay" aria-hidden="true">
      <div class="modal">
        <div class="modal-title">Select Library Context</div>
        <div class="modal-sub">Pinned items are injected into the next prompt in addition to semantic retrieval.</div>
        <div style="display:grid; grid-template-columns: 1fr 180px; gap:8px; margin-bottom:10px;">
          <input id="librarySearchInput" placeholder="Search library title/preview..." />
          <button id="libraryRefreshBtn" type="button">Refresh</button>
        </div>
        <div id="librarySelectList" class="modal-list"></div>
        <div class="modal-actions">
          <button id="librarySelectCancelBtn" type="button">Cancel</button>
          <button id="libraryClearBtn" type="button">Clear All</button>
          <button id="librarySelectApplyBtn" type="button" class="primary">Apply Selection</button>
        </div>
      </div>
    </div>

    <script>
      const chat = document.getElementById("chat");
      const ownerEl = document.getElementById("owner");
      const ownerLabel = document.getElementById("ownerLabel");
      const msgEl = document.getElementById("msg");
      const modeEl = document.getElementById("mode");
      const providerEl = document.getElementById("provider");
      const kEl = document.getElementById("k");
      const modelEl = document.getElementById("model");
      const thinkingEnabledEl = document.getElementById("thinkingEnabled");
      const thinkingLevelEl = document.getElementById("thinkingLevel");
      const showThinkingEl = document.getElementById("showThinking");
      const trueStreamingEl = document.getElementById("trueStreaming");

      const sendBtn = document.getElementById("sendBtn");
      const clearBtn = document.getElementById("clearBtn");
      const logoutBtn = document.getElementById("logoutBtn");
      const settingsBtn = document.getElementById("settingsBtn");
      const libraryBtn = document.getElementById("libraryBtn");
      const newChatBtn = document.getElementById("newChatBtn");
      const newChatNameEl = document.getElementById("newChatName");
      const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
      const historyList = document.getElementById("historyList");
      const ingestTitleEl = document.getElementById("ingestTitle");
      const ingestUrlEl = document.getElementById("ingestUrl");
      const ingestUrlBtn = document.getElementById("ingestUrlBtn");
      const ingestFileEl = document.getElementById("ingestFile");
      const ingestFileBtn = document.getElementById("ingestFileBtn");
      const ingestOutEl = document.getElementById("ingestOut");
      const flashFrontEl = document.getElementById("flashFront");
      const flashBackEl = document.getElementById("flashBack");
      const flashTagsEl = document.getElementById("flashTags");
      const flashAddBtn = document.getElementById("flashAddBtn");
      const flashFromReplyBtn = document.getElementById("flashFromReplyBtn");
      const flashRefreshBtn = document.getElementById("flashRefreshBtn");
      const flashDueOnlyEl = document.getElementById("flashDueOnly");
      const flashOutEl = document.getElementById("flashOut");
      const flashListEl = document.getElementById("flashList");
      const selectLibraryBtn = document.getElementById("selectLibraryBtn");
      const libraryCtxOutEl = document.getElementById("libraryCtxOut");
      const flashPreviewModalEl = document.getElementById("flashPreviewModal");
      const flashPreviewListEl = document.getElementById("flashPreviewList");
      const flashPreviewCancelBtn = document.getElementById("flashPreviewCancelBtn");
      const flashPreviewCreateBtn = document.getElementById("flashPreviewCreateBtn");
      const librarySelectModalEl = document.getElementById("librarySelectModal");
      const librarySearchInputEl = document.getElementById("librarySearchInput");
      const libraryRefreshBtn = document.getElementById("libraryRefreshBtn");
      const librarySelectListEl = document.getElementById("librarySelectList");
      const librarySelectCancelBtn = document.getElementById("librarySelectCancelBtn");
      const libraryClearBtn = document.getElementById("libraryClearBtn");
      const librarySelectApplyBtn = document.getElementById("librarySelectApplyBtn");
      const busy = document.getElementById("busy");
      const csrfToken = document.body.dataset.csrf || "";
      let pendingFlashPreviewCards = [];
      let selectedLibraryIds = [];
      let libraryModalSnapshot = [];

      function csrfFetch(url, options = {}) {
        const headers = new Headers(options.headers || {});
        headers.set("X-CSRF-Token", csrfToken);
        return fetch(url, { ...options, headers });
      }

      async function ensureAuth(res) {
        if (res.status === 401 || res.status === 403) {
          window.location.href = "/login";
          return false;
        }
        return true;
      }

      function setBusy(on) { busy.style.display = on ? "inline" : "none"; }
      function scrollToBottom() { chat.scrollTop = chat.scrollHeight; }

      function owner() {
        const raw = ownerEl.value.trim() || "default";
        const normalized = raw.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 128) || "default";
        ownerEl.value = normalized;
        ownerLabel.textContent = normalized;
        return normalized;
      }

      function selectedLibraryKey() {
        return `opensift_selected_library::${owner()}`;
      }

      function loadSelectedLibraryIds() {
        try {
          const raw = localStorage.getItem(selectedLibraryKey()) || "[]";
          const arr = JSON.parse(raw);
          selectedLibraryIds = Array.isArray(arr) ? arr.filter(x => typeof x === "string") : [];
        } catch (_) {
          selectedLibraryIds = [];
        }
        renderSelectedLibraryStatus();
      }

      function saveSelectedLibraryIds() {
        localStorage.setItem(selectedLibraryKey(), JSON.stringify(selectedLibraryIds.slice(0, 8)));
        renderSelectedLibraryStatus();
      }

      function renderSelectedLibraryStatus() {
        if (!selectedLibraryIds.length) {
          libraryCtxOutEl.textContent = "No pinned library items.";
          return;
        }
        libraryCtxOutEl.textContent = `${selectedLibraryIds.length} pinned item(s): ${selectedLibraryIds.join(", ")}`;
      }

      function addBubble(role, text, ts) {
        const row = document.createElement("div");
        row.className = "msg " + role;
        const bubble = document.createElement("div");
        bubble.className = "bubble";
        const textNode = document.createElement("div");
        textNode.textContent = text || "";
        bubble.appendChild(textNode);
        const refsWrap = document.createElement("div");
        refsWrap.className = "hint";
        refsWrap.style.marginTop = "8px";
        refsWrap.style.display = "none";
        bubble.appendChild(refsWrap);
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = ts || "";
        bubble.appendChild(meta);
        row.appendChild(bubble);
        chat.appendChild(row);
        scrollToBottom();
        return { textEl: textNode, bubbleEl: bubble, refsEl: refsWrap };
      }

      function renderReferences(containerEl, sources) {
        if (!containerEl) return;
        containerEl.innerHTML = "";
        const rows = Array.isArray(sources) ? sources : [];
        if (!rows.length) {
          containerEl.style.display = "none";
          return;
        }
        containerEl.style.display = "block";
        const title = document.createElement("div");
        title.textContent = "References";
        title.style.fontWeight = "600";
        title.style.marginBottom = "4px";
        containerEl.appendChild(title);

        for (let i = 0; i < rows.length; i++) {
          const src = rows[i] || {};
          const line = document.createElement("div");
          line.style.marginBottom = "2px";
          const label = document.createElement("span");
          const sourceName = (src.source || "source").toString();
          const kind = (src.kind || "").toString();
          const dist = src.distance === null || src.distance === undefined ? "" : ` · score ${Number(src.distance).toFixed(3)}`;
          label.textContent = `[${i + 1}] ${sourceName}${kind ? ` (${kind})` : ""}${dist}`;
          line.appendChild(label);
          const url = (src.url || "").toString().trim();
          if (url) {
            const sep = document.createElement("span");
            sep.textContent = " — ";
            line.appendChild(sep);
            const a = document.createElement("a");
            a.href = url;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.textContent = "open";
            line.appendChild(a);
          }
          containerEl.appendChild(line);
        }
      }

      function normalizeProviderAndModel(provider, model) {
        const p = (provider || "").trim().toLowerCase();
        const m = (model || "").trim();
        if (!m) return { provider: p, model: m, note: "" };
        const isClaudeModel = m.startsWith("claude-");
        const isGptModel = m.startsWith("gpt-");
        if ((p === "codex" || p === "openai") && isClaudeModel) {
          return {
            provider: p,
            model: "",
            note: `Model '${m}' is Claude-family and not valid for ${p}; using Auto model instead.`,
          };
        }
        if ((p === "claude" || p === "claude_code") && isGptModel) {
          return {
            provider: p,
            model: "",
            note: `Model '${m}' is GPT-family and not valid for ${p}; using Auto model instead.`,
          };
        }
        return { provider: p, model: m, note: "" };
      }

      function renderHistory(messages) {
        chat.innerHTML = "";
        for (const m of messages || []) {
          const b = addBubble(m.role || "assistant", m.text || "", m.ts || "");
          if ((m.role || "") === "assistant") {
            renderReferences(b.refsEl, m.sources || []);
          }
        }
      }

      async function sendStream() {
        const o = owner();
        const message = msgEl.value.trim();
        if (!message) return;

        addBubble("user", message, new Date().toISOString());
        msgEl.value = "";
        sendBtn.disabled = true;
        setBusy(true);

        const a = addBubble("assistant", "", new Date().toISOString());
        let latestSources = [];
        const statusEl = document.createElement("div");
        statusEl.className = "hint";
        statusEl.style.marginBottom = "6px";
        a.bubbleEl.insertBefore(statusEl, a.textEl);
        const statusLogEl = document.createElement("div");
        statusLogEl.className = "hint";
        statusLogEl.style.whiteSpace = "pre-wrap";
        statusLogEl.style.fontSize = "12px";
        statusLogEl.style.opacity = "0.9";
        statusLogEl.style.marginBottom = "6px";
        a.bubbleEl.insertBefore(statusLogEl, a.textEl);
        const statusLines = [];
        const pushStatus = (text) => {
          const line = (text || "").trim();
          if (!line) return;
          const stamped = `[${new Date().toLocaleTimeString()}] ${line}`;
          statusLines.push(stamped);
          if (statusLines.length > 10) statusLines.shift();
          statusLogEl.textContent = statusLines.join("\n");
        };

        const form = new FormData();
        form.append("owner", o);
        form.append("message", message);
        form.append("mode", modeEl.value);
        const normalized = normalizeProviderAndModel(providerEl.value, modelEl.value);
        form.append("provider", normalized.provider || providerEl.value);
        form.append("k", kEl.value);
        form.append("model", normalized.model);
        form.append("thinking_enabled", thinkingEnabledEl.checked ? "true" : "false");
        form.append("thinking_level", thinkingLevelEl.value || "medium");
        form.append("show_thinking", showThinkingEl.checked ? "true" : "false");
        form.append("true_streaming", trueStreamingEl.checked ? "true" : "false");
        form.append("selected_library_ids", selectedLibraryIds.join(","));
        if (normalized.note) {
          statusEl.textContent = normalized.note;
          pushStatus(normalized.note);
        }

        const controller = new AbortController();
        const timeoutMs = 600000;
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

        try {
          const res = await csrfFetch("/chat/stream", { method: "POST", body: form, signal: controller.signal });
          if (!(await ensureAuth(res))) return;
          if (!res.ok || !res.body) {
            a.textEl.textContent = "Streaming failed to start.";
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let idx;
            while ((idx = buffer.indexOf("\n")) >= 0) {
              const line = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 1);
              if (!line) continue;
              let evt;
              try { evt = JSON.parse(line); } catch { continue; }
              if (evt.type === "delta") a.textEl.textContent += (evt.text || "");
              if (evt.type === "sources") {
                latestSources = Array.isArray(evt.sources) ? evt.sources : [];
                renderReferences(a.refsEl, latestSources);
              }
              if (evt.type === "status" && showThinkingEl.checked) {
                statusEl.textContent = evt.text || "";
                pushStatus(evt.text || "");
              }
              if (evt.type === "error") {
                const msg = evt.message || "Request failed.";
                a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + `⚠️ ${msg}`;
                pushStatus(`Error: ${msg}`);
              }
              if (evt.type === "done") statusEl.textContent = "Completed.";
              scrollToBottom();
            }
          }
        } catch (err) {
          let recovered = false;
          try {
            const exp = await fetch(`/chat/session/export?owner=${encodeURIComponent(o)}`);
            if (exp.ok) {
              const data = await exp.json();
              const hist = data.history || [];
              for (let i = hist.length - 1; i >= 0; i--) {
                const m = hist[i];
                if (m && m.role === "assistant" && (m.text || "").trim()) {
                  a.textEl.textContent = m.text || "";
                  recovered = true;
                  break;
                }
              }
            }
          } catch (_) {}
          if (recovered) {
            statusEl.textContent = "Recovered from session cache.";
            pushStatus("Recovered from session cache.");
            return;
          }
          if (controller.signal.aborted) {
            const t = "⚠️ Request timed out while loading/retrieving. Please retry.";
            a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + t;
            pushStatus(t);
          } else {
            const t = "⚠️ Streaming interrupted. If this happened during first-run embedding download, retry once warmup completes.";
            a.textEl.textContent += (a.textEl.textContent ? "\n\n" : "") + t;
            pushStatus(t);
          }
          statusEl.textContent = "Failed.";
        } finally {
          clearTimeout(timeoutId);
          sendBtn.disabled = false;
          setBusy(false);
          await loadSessions();
        }
      }

      async function openLibrarySelectModal() {
        await loadLibraryChoices();
        librarySelectModalEl.classList.add("open");
        librarySelectModalEl.setAttribute("aria-hidden", "false");
      }

      function closeLibrarySelectModal() {
        librarySelectModalEl.classList.remove("open");
        librarySelectModalEl.setAttribute("aria-hidden", "true");
      }

      async function loadLibraryChoices() {
        const o = owner();
        const q = (librarySearchInputEl.value || "").trim();
        const u = `/chat/library/list?owner=${encodeURIComponent(o)}&q=${encodeURIComponent(q)}&page=1&page_size=100&sort_by=created_at&sort_dir=desc`;
        const res = await fetch(u);
        if (!(await ensureAuth(res))) return;
        if (!res.ok) {
          librarySelectListEl.innerHTML = `<div class="hint">Failed to load library sources.</div>`;
          return;
        }
        const data = await res.json();
        const items = data.items || [];
        libraryModalSnapshot = items;
        renderLibraryChoiceList(items);
      }

      function renderLibraryChoiceList(items) {
        librarySelectListEl.innerHTML = "";
        if (!items.length) {
          const hint = document.createElement("div");
          hint.className = "hint";
          hint.textContent = "No library items found.";
          librarySelectListEl.appendChild(hint);
          return;
        }
        for (const item of items) {
          const row = document.createElement("div");
          row.className = "preview-card";
          const head = document.createElement("div");
          head.className = "preview-head";

          const check = document.createElement("input");
          check.type = "checkbox";
          check.dataset.id = String(item.id || "");
          check.checked = selectedLibraryIds.includes(String(item.id || ""));
          head.appendChild(check);

          const front = document.createElement("div");
          front.className = "preview-front";
          front.textContent = item.title || "Untitled";
          head.appendChild(front);

          const back = document.createElement("div");
          back.className = "preview-back";
          back.textContent = item.preview || "";

          const meta = document.createElement("div");
          meta.className = "hint";
          meta.textContent = `${item.kind || "item"} · ${item.folder || "(no folder)"} · ${item.tags || "(no tags)"}`;

          row.appendChild(head);
          row.appendChild(back);
          row.appendChild(meta);
          librarySelectListEl.appendChild(row);
        }
      }

      function applyLibrarySelection() {
        const checks = Array.from(librarySelectListEl.querySelectorAll('input[type="checkbox"][data-id]'));
        const next = [];
        for (const c of checks) {
          if (!c.checked) continue;
          next.push(c.dataset.id);
          if (next.length >= 8) break;
        }
        selectedLibraryIds = next;
        saveSelectedLibraryIds();
        closeLibrarySelectModal();
      }

      async function clearChat() {
        const form = new FormData();
        form.append("owner", owner());
        const res = await csrfFetch("/chat/clear", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        chat.innerHTML = "";
        await loadSessions();
      }

      async function logout() {
        await csrfFetch("/logout", { method: "POST" });
        window.location.href = "/login";
      }

      async function loadSessions() {
        const res = await fetch("/chat/session/list");
        if (!(await ensureAuth(res))) return;
        if (!res.ok) return;
        const data = await res.json();
        const sessions = data.sessions || [];

        historyList.innerHTML = "";
        if (!sessions.length) {
          const hint = document.createElement("div");
          hint.className = "hint";
          hint.textContent = "No chats yet.";
          historyList.appendChild(hint);
          return;
        }

        for (const s of sessions) {
          const card = document.createElement("div");
          card.className = "session-item";

          const t = document.createElement("div");
          t.className = "session-item-title";
          t.textContent = s.owner || "";
          card.appendChild(t);

          const m = document.createElement("div");
          m.className = "session-item-meta";
          m.textContent = `${s.count || 0} msgs · ${s.last_ts || ""}`;
          card.appendChild(m);

          const actions = document.createElement("div");
          actions.className = "session-item-actions";

          const openBtn = document.createElement("button");
          openBtn.type = "button";
          openBtn.textContent = "Open";
          openBtn.addEventListener("click", () => openSession(s.owner));

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "danger";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", () => deleteSessionByOwner(s.owner));

          actions.appendChild(openBtn);
          actions.appendChild(delBtn);
          card.appendChild(actions);
          historyList.appendChild(card);
        }
      }

      async function openSession(ownerName) {
        ownerEl.value = ownerName;
        owner();
        const res = await fetch(`/chat/session/export?owner=${encodeURIComponent(ownerName)}`);
        if (!(await ensureAuth(res))) return;
        if (!res.ok) return;
        const data = await res.json();
        renderHistory(data.history || []);
      }

      async function deleteSessionByOwner(ownerName) {
        const reallyDelete = confirm(
          `Delete chat '${ownerName}'?\n\nYou can choose whether to also delete linked library items in the next step.`
        );
        if (!reallyDelete) return;

        const deleteLinkedLibrary = confirm(
          `Also delete library items linked to '${ownerName}'?\n\nOK = delete linked library items\nCancel = keep library items`
        );

        const form = new FormData();
        form.append("owner", ownerName);
        form.append("delete_library_items", deleteLinkedLibrary ? "true" : "false");
        const res = await csrfFetch("/chat/session/delete", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        if (!res.ok) return;
        const data = await res.json().catch(() => ({}));
        if (deleteLinkedLibrary) {
          const n = Number(data.deleted_library_count || 0);
          ingestOutEl.textContent = `Deleted chat '${ownerName}' and ${n} linked library item(s).`;
        } else {
          ingestOutEl.textContent = `Deleted chat '${ownerName}'. Linked library items were kept.`;
        }
        if (owner() === ownerName) chat.innerHTML = "";
        await loadSessions();
      }

      async function startNewChat() {
        const typed = (newChatNameEl.value || "").trim();
        const d = new Date();
        const fallback = `chat-${d.getFullYear()}${String(d.getMonth()+1).padStart(2,"0")}${String(d.getDate()).padStart(2,"0")}-${String(d.getHours()).padStart(2,"0")}${String(d.getMinutes()).padStart(2,"0")}`;
        const nextOwner = typed || fallback;

        const form = new FormData();
        form.append("owner", nextOwner);
        const res = await csrfFetch("/chat/session/new", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;

        newChatNameEl.value = "";
        ownerEl.value = nextOwner;
        owner();
        chat.innerHTML = "";
        await loadSessions();
      }

      async function ingestUrl() {
        const url = (ingestUrlEl.value || "").trim();
        if (!url) return;
        ingestOutEl.textContent = "Ingesting URL...";
        const form = new FormData();
        form.append("owner", owner());
        form.append("url", url);
        form.append("source_title", (ingestTitleEl.value || "").trim());
        const res = await csrfFetch("/chat/ingest/url", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        const data = await res.json();
        ingestOutEl.textContent = data?.assistant?.text || `Ingest failed (HTTP ${res.status}).`;
      }

      async function ingestFile() {
        const file = ingestFileEl.files && ingestFileEl.files[0];
        if (!file) return;
        ingestOutEl.textContent = "Uploading + ingesting file...";
        const form = new FormData();
        form.append("owner", owner());
        form.append("file", file);
        const res = await csrfFetch("/chat/ingest/file", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        const data = await res.json();
        ingestOutEl.textContent = data?.assistant?.text || `File ingest failed (HTTP ${res.status}).`;
        ingestFileEl.value = "";
      }

      function renderFlashcards(cards) {
        flashListEl.innerHTML = "";
        const rows = cards || [];
        if (!rows.length) {
          const hint = document.createElement("div");
          hint.className = "hint";
          hint.textContent = "No flashcards for this owner.";
          flashListEl.appendChild(hint);
          return;
        }

        for (const c of rows) {
          const card = document.createElement("div");
          card.className = "fc-card";

          const front = document.createElement("div");
          front.className = "fc-front";
          front.textContent = c.front || "(no front)";
          card.appendChild(front);

          const back = document.createElement("div");
          back.className = "fc-back";
          back.textContent = c.back || "";
          back.style.display = "none";
          card.appendChild(back);

          const meta = document.createElement("div");
          meta.className = "fc-meta";
          const due = c.due_at ? `due: ${String(c.due_at).slice(0, 19).replace("T", " ")}` : "due: n/a";
          const tags = c.tags ? ` | tags: ${c.tags}` : "";
          meta.textContent = `${due}${tags}`;
          card.appendChild(meta);

          const actions = document.createElement("div");
          actions.className = "fc-actions";

          const toggleBtn = document.createElement("button");
          toggleBtn.type = "button";
          toggleBtn.textContent = "Show Back";
          toggleBtn.addEventListener("click", () => {
            const hidden = back.style.display === "none";
            back.style.display = hidden ? "block" : "none";
            toggleBtn.textContent = hidden ? "Hide Back" : "Show Back";
          });
          actions.appendChild(toggleBtn);

          const ratings = ["again", "hard", "good", "easy"];
          for (const rating of ratings) {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = rating;
            btn.addEventListener("click", async () => {
              const form = new FormData();
              form.append("owner", owner());
              form.append("card_id", c.id || "");
              form.append("rating", rating);
              const res = await csrfFetch("/chat/flashcards/review", { method: "POST", body: form });
              if (!(await ensureAuth(res))) return;
              const data = await res.json();
              flashOutEl.textContent = data.ok ? `Reviewed: ${rating}` : `Review failed (${data.error || res.status})`;
              await loadFlashcards();
            });
            actions.appendChild(btn);
          }

          const delBtn = document.createElement("button");
          delBtn.type = "button";
          delBtn.className = "danger";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", async () => {
            const form = new FormData();
            form.append("owner", owner());
            form.append("card_id", c.id || "");
            const res = await csrfFetch("/chat/flashcards/delete", { method: "POST", body: form });
            if (!(await ensureAuth(res))) return;
            const data = await res.json();
            flashOutEl.textContent = data.ok ? "Deleted card." : `Delete failed (${data.error || res.status})`;
            await loadFlashcards();
          });
          actions.appendChild(delBtn);

          card.appendChild(actions);
          flashListEl.appendChild(card);
        }
      }

      async function loadFlashcards() {
        const o = owner();
        const dueOnly = flashDueOnlyEl.checked ? "true" : "false";
        const res = await fetch(`/chat/flashcards/list?owner=${encodeURIComponent(o)}&due_only=${dueOnly}`);
        if (!(await ensureAuth(res))) return;
        if (!res.ok) {
          flashOutEl.textContent = `Load failed (HTTP ${res.status}).`;
          return;
        }
        const data = await res.json();
        renderFlashcards(data.cards || []);
      }

      async function addFlashcard() {
        const front = (flashFrontEl.value || "").trim();
        const back = (flashBackEl.value || "").trim();
        const tags = (flashTagsEl.value || "").trim();
        if (!front || !back) {
          flashOutEl.textContent = "Front and back are required.";
          return;
        }
        const form = new FormData();
        form.append("owner", owner());
        form.append("front", front);
        form.append("back", back);
        form.append("tags", tags);
        const res = await csrfFetch("/chat/flashcards/add", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return;
        const data = await res.json();
        if (!res.ok || !data.ok) {
          flashOutEl.textContent = `Add failed (${data.error || res.status}).`;
          return;
        }
        flashFrontEl.value = "";
        flashBackEl.value = "";
        flashTagsEl.value = "";
        flashOutEl.textContent = "Added flashcard.";
        await loadFlashcards();
      }

      function makeFrontFromText(text) {
        const line = (text || "")
          .replace(/\s+/g, " ")
          .replace(/^#+\s*/g, "")
          .trim();
        if (!line) return "From latest reply";
        return line.slice(0, 120);
      }

      function buildFlashcardsFromReply(text) {
        const raw = (text || "").trim();
        if (!raw) return [];
        const lines = raw.split(/\r?\n/);

        const sections = [];
        let currentTitle = "";
        let currentBody = [];

        const flush = () => {
          const body = currentBody.join("\n").trim();
          if (!body) return;
          sections.push({
            title: currentTitle.trim(),
            body,
          });
          currentBody = [];
        };

        for (const lineRaw of lines) {
          const line = lineRaw.trim();
          const isMdHeading = /^#{1,6}\s+/.test(line);
          const isColonHeading = /^[A-Z][A-Za-z0-9 ()/_-]{2,60}:$/.test(line);
          if (isMdHeading || isColonHeading) {
            flush();
            currentTitle = line.replace(/^#{1,6}\s+/, "").replace(/:$/, "").trim();
            continue;
          }
          currentBody.push(lineRaw);
        }
        flush();

        // If headings were not present, fall back to paragraph blocks.
        if (!sections.length) {
          const blocks = raw
            .split(/\n\s*\n+/)
            .map((b) => b.trim())
            .filter(Boolean);
          for (const b of blocks) {
            sections.push({ title: "", body: b });
          }
        }

        const cards = [];
        for (const s of sections) {
          const front = s.title ? s.title.slice(0, 120) : makeFrontFromText(s.body);
          const back = s.body.slice(0, 1500).trim();
          if (!front || !back) continue;
          cards.push({ front, back });
          if (cards.length >= 8) break;
        }
        return cards;
      }

      async function createFlashcard(ownerName, front, back, tags = "from-chat") {
        const form = new FormData();
        form.append("owner", ownerName);
        form.append("front", front);
        form.append("back", back);
        form.append("tags", tags);
        const res = await csrfFetch("/chat/flashcards/add", { method: "POST", body: form });
        if (!(await ensureAuth(res))) return { ok: false, authRedirect: true };
        const payload = await res.json();
        return { ok: !!(res.ok && payload.ok), error: payload.error || `HTTP ${res.status}` };
      }

      function closeFlashPreviewModal() {
        flashPreviewModalEl.classList.remove("open");
        flashPreviewModalEl.setAttribute("aria-hidden", "true");
      }

      function openFlashPreviewModal(cards) {
        pendingFlashPreviewCards = cards.slice();
        flashPreviewListEl.innerHTML = "";

        for (let i = 0; i < cards.length; i++) {
          const c = cards[i];
          const row = document.createElement("div");
          row.className = "preview-card";

          const head = document.createElement("div");
          head.className = "preview-head";

          const check = document.createElement("input");
          check.type = "checkbox";
          check.checked = true;
          check.dataset.index = String(i);

          const front = document.createElement("div");
          front.className = "preview-front";
          front.textContent = c.front || "(untitled)";

          head.appendChild(check);
          head.appendChild(front);
          row.appendChild(head);

          const fields = document.createElement("div");
          fields.className = "preview-fields";

          const frontInput = document.createElement("input");
          frontInput.type = "text";
          frontInput.value = c.front || "";
          frontInput.placeholder = "Card front";
          frontInput.dataset.field = "front";
          frontInput.dataset.index = String(i);

          const backInput = document.createElement("textarea");
          backInput.value = c.back || "";
          backInput.placeholder = "Card back";
          backInput.dataset.field = "back";
          backInput.dataset.index = String(i);

          fields.appendChild(frontInput);
          fields.appendChild(backInput);
          row.appendChild(fields);

          flashPreviewListEl.appendChild(row);
        }

        flashPreviewModalEl.classList.add("open");
        flashPreviewModalEl.setAttribute("aria-hidden", "false");
      }

      async function createSelectedPreviewFlashcards() {
        const o = owner();
        const checks = Array.from(flashPreviewListEl.querySelectorAll('input[type="checkbox"][data-index]'));
        const edited = new Map();
        const fieldEls = Array.from(flashPreviewListEl.querySelectorAll('[data-field][data-index]'));
        for (const el of fieldEls) {
          const idx = Number(el.dataset.index || "-1");
          const field = el.dataset.field || "";
          if (idx < 0 || !field) continue;
          if (!edited.has(idx)) edited.set(idx, { front: "", back: "" });
          const bucket = edited.get(idx);
          bucket[field] = (el.value || "").trim();
        }

        const selected = [];
        for (const check of checks) {
          if (!check.checked) continue;
          const idx = Number(check.dataset.index || "-1");
          if (idx >= 0 && idx < pendingFlashPreviewCards.length) {
            const base = pendingFlashPreviewCards[idx];
            const patch = edited.get(idx) || {};
            const front = (patch.front || base.front || "").trim();
            const back = (patch.back || base.back || "").trim();
            if (!front || !back) continue;
            selected.push({ front, back });
          }
        }
        if (!selected.length) {
          flashOutEl.textContent = "No valid cards selected (front/back are required).";
          closeFlashPreviewModal();
          return;
        }

        flashOutEl.textContent = `Creating ${selected.length} selected flashcard(s)...`;
        let created = 0;
        let failed = 0;
        for (const card of selected) {
          const result = await createFlashcard(o, card.front, card.back, "from-chat,auto-split");
          if (result.authRedirect) return;
          if (result.ok) created += 1;
          else failed += 1;
        }

        closeFlashPreviewModal();
        flashOutEl.textContent = `Created ${created} flashcard(s)${failed ? ` (${failed} failed)` : ""}.`;
        await loadFlashcards();
      }

      async function addFlashcardFromLastReply() {
        const o = owner();
        flashOutEl.textContent = "Creating flashcards from latest assistant reply...";
        const exp = await fetch(`/chat/session/export?owner=${encodeURIComponent(o)}`);
        if (!(await ensureAuth(exp))) return;
        if (!exp.ok) {
          flashOutEl.textContent = `Load failed (HTTP ${exp.status}).`;
          return;
        }
        const data = await exp.json();
        const history = data.history || [];
        let lastAssistantText = "";
        for (let i = history.length - 1; i >= 0; i--) {
          const m = history[i];
          if (m && m.role === "assistant" && (m.text || "").trim()) {
            lastAssistantText = (m.text || "").trim();
            break;
          }
        }
        if (!lastAssistantText) {
          flashOutEl.textContent = "No assistant reply found for this owner.";
          return;
        }

        const cards = buildFlashcardsFromReply(lastAssistantText);
        if (!cards.length) {
          flashOutEl.textContent = "Could not extract card sections from latest reply.";
          return;
        }
        openFlashPreviewModal(cards);
      }

      sendBtn.addEventListener("click", sendStream);
      clearBtn.addEventListener("click", clearChat);
      logoutBtn.addEventListener("click", logout);
      settingsBtn.addEventListener("click", () => {
        window.location.href = `/settings?owner=${encodeURIComponent(owner())}`;
      });
      libraryBtn.addEventListener("click", () => {
        window.location.href = `/library?owner=${encodeURIComponent(owner())}`;
      });
      refreshHistoryBtn.addEventListener("click", loadSessions);
      newChatBtn.addEventListener("click", startNewChat);
      ingestUrlBtn.addEventListener("click", ingestUrl);
      ingestFileBtn.addEventListener("click", ingestFile);
      flashAddBtn.addEventListener("click", addFlashcard);
      flashFromReplyBtn.addEventListener("click", addFlashcardFromLastReply);
      flashRefreshBtn.addEventListener("click", loadFlashcards);
      flashPreviewCancelBtn.addEventListener("click", closeFlashPreviewModal);
      flashPreviewCreateBtn.addEventListener("click", createSelectedPreviewFlashcards);
      flashPreviewModalEl.addEventListener("click", (e) => {
        if (e.target === flashPreviewModalEl) closeFlashPreviewModal();
      });
      selectLibraryBtn.addEventListener("click", openLibrarySelectModal);
      libraryRefreshBtn.addEventListener("click", loadLibraryChoices);
      librarySearchInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          loadLibraryChoices();
        }
      });
      librarySelectCancelBtn.addEventListener("click", closeLibrarySelectModal);
      libraryClearBtn.addEventListener("click", () => {
        selectedLibraryIds = [];
        saveSelectedLibraryIds();
        renderLibraryChoiceList(libraryModalSnapshot);
      });
      librarySelectApplyBtn.addEventListener("click", applyLibrarySelection);
      librarySelectModalEl.addEventListener("click", (e) => {
        if (e.target === librarySelectModalEl) closeLibrarySelectModal();
      });
      flashDueOnlyEl.addEventListener("change", loadFlashcards);
      flashBackEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addFlashcard();
        }
      });
      newChatNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          startNewChat();
        }
      });
      ingestUrlEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          ingestUrl();
        }
      });
      ownerEl.addEventListener("change", async () => {
        owner();
        loadSelectedLibraryIds();
        const res = await fetch(`/chat/session/export?owner=${encodeURIComponent(owner())}`);
        if (!(await ensureAuth(res))) return;
        if (res.ok) {
          const data = await res.json();
          renderHistory(data.history || []);
        }
        await loadFlashcards();
      });
      msgEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendStream();
        }
      });

      owner();
      loadSelectedLibraryIds();
      scrollToBottom();
      loadSessions();
      loadFlashcards();
    </script>
  </body>
</html>
